# -*- coding: utf-8 -*-
"""T3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12QeT3f4QvPIvPHGAAnIJFPMKHiukokhL
"""

#Punto 1

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import os

class Simulador:
    def __init__(self):
        plt.rcParams['figure.figsize'] = (12, 8)

    def rk4(self, f, y0, t_span, h=0.01):
        t0, tf = t_span
        n = int((tf - t0) / h)
        t = np.linspace(t0, tf, n+1)
        y = np.zeros((n+1, len(y0)))
        y[0] = y0
        for i in range(n):
            k1 = h * f(t[i], y[i])
            k2 = h * f(t[i] + h/2, y[i] + k1/2)
            k3 = h * f(t[i] + h/2, y[i] + k2/2)
            k4 = h * f(t[i] + h, y[i] + k3)
            y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4)/6
        return t, y

    def sistema1_pdf(self, pdf):
        a, b, g, d = 2, 1.5, 0.3, 0.4
        x0, y0 = 3, 2
        def f(t, s):
            x, y = s
            return np.array([a*x - b*x*y, -g*y + d*x*y])

        t, sol = self.rk4(f, [x0, y0], (0, 50), h=0.01)
        x, y = sol[:,0], sol[:,1]
        eps = 1e-10
        V = d*x - g*np.log(np.maximum(x,eps)) + b*y - a*np.log(np.maximum(y,eps))

        fig, axs = plt.subplots(2,2,figsize=(12,8))
        fig.suptitle('Sistema 1.a: Depredador-Presa (Lotka-Volterra)', fontsize=16, fontweight='bold')

        axs[0,0].plot(x,y, 'b-', linewidth=2)
        axs[0,0].set_title("Retrato de fase (x vs y)")
        axs[0,0].set_xlabel("x (Presa)"); axs[0,0].set_ylabel("y (Depredador)")
        axs[0,0].grid(True, alpha=0.3)

        axs[0,1].plot(t,x,label="x (Presa)", linewidth=2)
        axs[0,1].plot(t,y,label="y (Depredador)", linewidth=2)
        axs[0,1].legend(); axs[0,1].set_title("Evolución en el tiempo")
        axs[0,1].set_xlabel("t"); axs[0,1].set_ylabel("Población")
        axs[0,1].grid(True, alpha=0.3)

        axs[1,0].plot(t,V, 'g-', linewidth=2)
        axs[1,0].set_title("Cantidad conservada V vs t")
        axs[1,0].set_xlabel("t"); axs[1,0].set_ylabel("V")
        axs[1,0].grid(True, alpha=0.3)

        X,Y = np.meshgrid(np.linspace(0.5,max(x)*1.1,20), np.linspace(0.5,max(y)*1.1,15))
        DX = a*X - b*X*Y
        DY = -g*Y + d*X*Y
        M = np.sqrt(DX**2+DY**2); M[M==0]=1
        axs[1,1].quiver(X,Y,DX/M,DY/M, alpha=0.6)
        axs[1,1].plot(x,y,'r-', linewidth=2, label='Trayectoria')
        axs[1,1].set_title("Campo vectorial con trayectoria")
        axs[1,1].set_xlabel("x (Presa)"); axs[1,1].set_ylabel("y (Depredador)")
        axs[1,1].legend()
        axs[1,1].grid(True, alpha=0.3)

        plt.tight_layout()
        pdf.savefig(fig, dpi=300, bbox_inches='tight')
        plt.show()
        plt.close()
        return t, sol, V

    def sistema2_pdf(self, pdf):
        q, B0, E0, m, k = 7.5284, 0.438, 0.7423, 3.8428, 1.0014
        c = 1.0
        def f(t, s):
            x, y, vx, vy = s
            dvx = (q/m)*(E0*(np.sin(k*x)+k*x*np.cos(k*x)) - (B0/c)*vy)
            dvy = (q*B0)/(m*c)*vx
            return np.array([vx, vy, dvx, dvy])

        t, sol = self.rk4(f, [0,0,1,0.5], (0,30), h=0.01)
        x,y,vx,vy = sol[:,0],sol[:,1],sol[:,2],sol[:,3]
        Pi_y = m*vy - (q*B0*x)/c
        E = 0.5*m*(vx**2+vy**2) - q*E0*x*np.sin(k*x)

        fig, axs = plt.subplots(2,2,figsize=(12,8))
        fig.suptitle('Sistema 1.b: Partícula Cargada en Campos Electromagnéticos', fontsize=16, fontweight='bold')

        axs[0,0].plot(x,y, 'b-', linewidth=2)
        axs[0,0].set_title("Trayectoria (x vs y)")
        axs[0,0].set_xlabel("x"); axs[0,0].set_ylabel("y")
        axs[0,0].grid(True, alpha=0.3)

        axs[0,1].plot(t,x,label="x vs t", linewidth=2)
        axs[0,1].plot(t,y,label="y vs t", linewidth=2)
        axs[0,1].legend(); axs[0,1].set_title("Posición vs tiempo")
        axs[0,1].set_xlabel("t"); axs[0,1].set_ylabel("Posición")
        axs[0,1].grid(True, alpha=0.3)

        axs[1,0].plot(t,vx,label="vx vs t", linewidth=2)
        axs[1,0].plot(t,vy,label="vy vs t", linewidth=2)
        axs[1,0].legend(); axs[1,0].set_title("Velocidades vs tiempo")
        axs[1,0].set_xlabel("t"); axs[1,0].set_ylabel("Velocidad")
        axs[1,0].grid(True, alpha=0.3)

        axs[1,1].plot(t,Pi_y,label="Πy vs t", linewidth=2)
        axs[1,1].plot(t,E,label="E vs t", linewidth=2)
        axs[1,1].legend(); axs[1,1].set_title("Cantidades conservadas")
        axs[1,1].set_xlabel("t"); axs[1,1].set_ylabel("Valor")
        axs[1,1].grid(True, alpha=0.3)

        plt.tight_layout()
        pdf.savefig(fig, dpi=300, bbox_inches='tight')
        plt.show()
        plt.close()
        return t, sol, Pi_y, E

    def sistema3_pdf(self, pdf):
        G, m = 1, 1.7
        def f(t,s):
            x1,y1,x2,y2,vx1,vy1,vx2,vy2 = s
            r = np.sqrt((x2-x1)**2+(y2-y1)**2)
            if r<1e-10: r=1e-10
            F = G*m*m/r**2
            fx,fy = F*(x2-x1)/r, F*(y2-y1)/r
            ax1,ay1 = fx/m,fy/m
            ax2,ay2 = -fx/m,-fy/m
            return np.array([vx1,vy1,vx2,vy2,ax1,ay1,ax2,ay2])

        s0 = [0,0,1,1,0,0.5,0,-0.5]
        t, sol = self.rk4(f,s0,(0,10),h=0.001)
        x1,y1,x2,y2,vx1,vy1,vx2,vy2 = sol.T
        r = np.sqrt((x2-x1)**2+(y2-y1)**2)
        E = 0.5*m*(vx1**2+vy1**2+vx2**2+vy2**2) - G*m*m/r
        L = m*(x1*vy1 - y1*vx1 + x2*vy2 - y2*vx2)

        fig, axs = plt.subplots(2,3,figsize=(15,8))
        fig.suptitle('Sistema 1.c: Dos Cuerpos Gravitatorios', fontsize=16, fontweight='bold')

        axs[0,0].plot(x1,y1,label="Cuerpo 1", linewidth=2)
        axs[0,0].plot(x2,y2,label="Cuerpo 2", linewidth=2)
        axs[0,0].legend(); axs[0,0].set_title("Órbitas (x vs y)")
        axs[0,0].set_xlabel("x"); axs[0,0].set_ylabel("y")
        axs[0,0].grid(True, alpha=0.3)

        axs[0,1].plot(t,x1,label="x1 vs t", linewidth=2)
        axs[0,1].plot(t,y1,label="y1 vs t", linewidth=2)
        axs[0,1].plot(t,x2,label="x2 vs t", linewidth=2)
        axs[0,1].plot(t,y2,label="y2 vs t", linewidth=2)
        axs[0,1].legend(); axs[0,1].set_title("Posiciones vs tiempo")
        axs[0,1].set_xlabel("t"); axs[0,1].set_ylabel("Posición")
        axs[0,1].grid(True, alpha=0.3)

        axs[0,2].plot(t,r, 'purple', linewidth=2)
        axs[0,2].set_title("Separación r vs t")
        axs[0,2].set_xlabel("t"); axs[0,2].set_ylabel("r")
        axs[0,2].grid(True, alpha=0.3)

        axs[1,0].plot(t,E, 'red', linewidth=2)
        axs[1,0].set_title("Energía vs t")
        axs[1,0].set_xlabel("t"); axs[1,0].set_ylabel("E")
        axs[1,0].grid(True, alpha=0.3)

        axs[1,1].plot(t,L, 'green', linewidth=2)
        axs[1,1].set_title("Momento angular vs t")
        axs[1,1].set_xlabel("t"); axs[1,1].set_ylabel("L")
        axs[1,1].grid(True, alpha=0.3)

        v1 = np.sqrt(vx1**2+vy1**2); v2 = np.sqrt(vx2**2+vy2**2)
        axs[1,2].plot(t,v1,label="v1 vs t", linewidth=2)
        axs[1,2].plot(t,v2,label="v2 vs t", linewidth=2)
        axs[1,2].legend(); axs[1,2].set_title("Velocidades vs tiempo")
        axs[1,2].set_xlabel("t"); axs[1,2].set_ylabel("Velocidad")
        axs[1,2].grid(True, alpha=0.3)

        plt.tight_layout()
        pdf.savefig(fig, dpi=300, bbox_inches='tight')
        plt.show()
        plt.close()
        return t, sol, E, L

    def generar_pdf_integrado(self):
        with PdfPages('1.X.pdf') as pdf:
            t1, sol1, V1 = self.sistema1_pdf(pdf)
            t2, sol2, Pi_y2, E2 = self.sistema2_pdf(pdf)
            t3, sol3, E3, L3 = self.sistema3_pdf(pdf)

    def sistema1(self):
        a, b, g, d = 2, 1.5, 0.3, 0.4
        x0, y0 = 3, 2
        def f(t, s):
            x, y = s
            return np.array([a*x - b*x*y, -g*y + d*x*y])
        t, sol = self.rk4(f, [x0, y0], (0, 50), h=0.01)
        x, y = sol[:,0], sol[:,1]
        eps = 1e-10
        V = d*x - g*np.log(np.maximum(x,eps)) + b*y - a*np.log(np.maximum(y,eps))

        fig, axs = plt.subplots(2,2,figsize=(12,8))

        axs[0,0].plot(x,y)
        axs[0,0].set_title("Retrato de fase (x vs y)")
        axs[0,0].set_xlabel("x"); axs[0,0].set_ylabel("y")

        axs[0,1].plot(t,x,label="x vs t")
        axs[0,1].plot(t,y,label="y vs t")
        axs[0,1].legend(); axs[0,1].set_title("Evolución en el tiempo")
        axs[0,1].set_xlabel("t")

        axs[1,0].plot(t,V)
        axs[1,0].set_title("Cantidad conservada V vs t")
        axs[1,0].set_xlabel("t")

        X,Y = np.meshgrid(np.linspace(0.5,max(x)*1.1,20), np.linspace(0.5,max(y)*1.1,15))
        DX = a*X - b*X*Y
        DY = -g*Y + d*X*Y
        M = np.sqrt(DX**2+DY**2); M[M==0]=1
        axs[1,1].quiver(X,Y,DX/M,DY/M)
        axs[1,1].plot(x,y,'r-')
        axs[1,1].set_title("Campo vectorial con trayectoria (x vs y)")
        axs[1,1].set_xlabel("x"); axs[1,1].set_ylabel("y")

        plt.tight_layout()
        plt.savefig("1.a.pdf")
        plt.show()
        return t, sol, V

    def sistema2(self):
        q, B0, E0, m, k = 7.5284, 0.438, 0.7423, 3.8428, 1.0014
        c = 1.0
        def f(t, s):
            x, y, vx, vy = s
            dvx = (q/m)*(E0*(np.sin(k*x)+k*x*np.cos(k*x)) - (B0/c)*vy)
            dvy = (q*B0)/(m*c)*vx
            return np.array([vx, vy, dvx, dvy])

        t, sol = self.rk4(f, [0,0,1,0.5], (0,30), h=0.01)
        x,y,vx,vy = sol[:,0],sol[:,1],sol[:,2],sol[:,3]
        Pi_y = m*vy - (q*B0*x)/c
        E = 0.5*m*(vx**2+vy**2) - q*E0*x*np.sin(k*x)

        fig, axs = plt.subplots(2,2,figsize=(12,8))

        axs[0,0].plot(x,y)
        axs[0,0].set_title("Trayectoria (x vs y)")
        axs[0,0].set_xlabel("x"); axs[0,0].set_ylabel("y")

        axs[0,1].plot(t,x,label="x vs t"); axs[0,1].plot(t,y,label="y vs t")
        axs[0,1].legend(); axs[0,1].set_title("Posición vs tiempo")
        axs[0,1].set_xlabel("t")

        axs[1,0].plot(t,vx,label="vx vs t"); axs[1,0].plot(t,vy,label="vy vs t")
        axs[1,0].legend(); axs[1,0].set_title("Velocidades vs tiempo")
        axs[1,0].set_xlabel("t")

        axs[1,1].plot(t,Pi_y,label="Pi_y vs t"); axs[1,1].plot(t,E,label="E vs t")
        axs[1,1].legend(); axs[1,1].set_title("Cantidades conservadas")
        axs[1,1].set_xlabel("t")

        plt.tight_layout()
        plt.savefig("1.b.pdf")
        plt.show()
        return t, sol, Pi_y, E

    def sistema3(self):
        G, m = 1, 1.7
        def f(t,s):
            x1,y1,x2,y2,vx1,vy1,vx2,vy2 = s
            r = np.sqrt((x2-x1)**2+(y2-y1)**2)
            if r<1e-10: r=1e-10
            F = G*m*m/r**2
            fx,fy = F*(x2-x1)/r, F*(y2-y1)/r
            ax1,ay1 = fx/m,fy/m
            ax2,ay2 = -fx/m,-fy/m
            return np.array([vx1,vy1,vx2,vy2,ax1,ay1,ax2,ay2])

        s0 = [0,0,1,1,0,0.5,0,-0.5]
        t, sol = self.rk4(f,s0,(0,10),h=0.001)
        x1,y1,x2,y2,vx1,vy1,vx2,vy2 = sol.T
        r = np.sqrt((x2-x1)**2+(y2-y1)**2)
        E = 0.5*m*(vx1**2+vy1**2+vx2**2+vy2**2) - G*m*m/r
        L = m*(x1*vy1 - y1*vx1 + x2*vy2 - y2*vx2)

        fig, axs = plt.subplots(2,3,figsize=(15,8))

        axs[0,0].plot(x1,y1,label="Cuerpo 1"); axs[0,0].plot(x2,y2,label="Cuerpo 2")
        axs[0,0].legend(); axs[0,0].set_title("Órbitas (x vs y)")
        axs[0,0].set_xlabel("x"); axs[0,0].set_ylabel("y")

        axs[0,1].plot(t,x1,label="x1 vs t"); axs[0,1].plot(t,y1,label="y1 vs t")
        axs[0,1].plot(t,x2,label="x2 vs t"); axs[0,1].plot(t,y2,label="y2 vs t")
        axs[0,1].legend(); axs[0,1].set_title("Posiciones vs tiempo")
        axs[0,1].set_xlabel("t")

        axs[0,2].plot(t,r)
        axs[0,2].set_title("Separación r vs t")
        axs[0,2].set_xlabel("t")

        axs[1,0].plot(t,E)
        axs[1,0].set_title("Energía vs t")
        axs[1,0].set_xlabel("t")

        axs[1,1].plot(t,L)
        axs[1,1].set_title("Momento angular vs t")
        axs[1,1].set_xlabel("t")

        v1 = np.sqrt(vx1**2+vy1**2); v2 = np.sqrt(vx2**2+vy2**2)
        axs[1,2].plot(t,v1,label="v1 vs t"); axs[1,2].plot(t,v2,label="v2 vs t")
        axs[1,2].legend(); axs[1,2].set_title("Velocidades vs tiempo")
        axs[1,2].set_xlabel("t")

        plt.tight_layout()
        plt.savefig("1.c.pdf")
        plt.show()
        return t, sol, E, L

if __name__ == "__main__":
    sim = Simulador()
    sim.generar_pdf_integrado()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
m=10.01
v0=140
g=9.773
A=1.642
B=40.624
C=2.36
def f_fricc(y,vx,vy):
  v=np.sqrt(vx**2+vy**2)
  betta=A*(1-(y/B))**C
  ffx=-betta*(v) * vx
  ffy=-betta*(v) * vy
  return ffx,ffy

def a(y,vx,vy):
  fx,fy=f_fricc(y,vx,vy)
  ax=fx/m
  ay=fy/m -g
  return ax,ay

def rhs(t, s):
    x, y, vx, vy = s
    ax, ay = a(y, vx, vy)
    return [vx, vy, ax, ay]

def ev_ground(t, s):
    return s[1]  # y
ev_ground.terminal = True
ev_ground.direction = -1.0

def integrar_trayectoria(v0, theta_deg, t_max=60.0):
    th = np.deg2rad(theta_deg)
    s0 = [0.0, 0.0, v0*np.cos(th), v0*np.sin(th)]
    sol = solve_ivp(rhs, (0.0, t_max), s0,
                    events=[ev_ground],
                    rtol=1e-8, atol=1e-10, max_step=0.02)
    return sol
angles = np.linspace(10, 80, 80)
v0 = 140.0

alcances = []

for theta in angles:
    sol = integrar_trayectoria(v0, theta)
    x = sol.y[0]
    y = sol.y[1]
    # Si terminó por evento de suelo y y[-1] < 0, corrige linealmente para tocar y=0 exacto
    if y[-1] < 0 and len(y) >= 2:
        y1, y2 = y[-2], y[-1]
        x1, x2 = x[-2], x[-1]
        if (y2 - y1) != 0:
            alpha = (0 - y1) / (y2 - y1)
            x_final = x1 + alpha * (x2 - x1)
        else:
            x_final = x[-1]
    else:
        x_final = x[-1]
    alcances.append(x_final)

alcances = np.array(alcances)
i_max = int(np.argmax(alcances))
theta_star = float(angles[i_max])
x_star = float(alcances[i_max])
print(f"Ángulo óptimo ≈ {theta_star:.2f}°  —  Alcance máximo ≈ {x_star:.3f} m")

# === Gráfica con marca del máximo ===
plt.figure(figsize=(7,5))
plt.plot(angles, alcances, 'o-', color='tab:blue', label='Alcance')
plt.scatter([theta_star], [x_star], s=80, color='red', zorder=5, label='Máximo')
plt.axvline(theta_star, color='red', linestyle='--', alpha=0.5)
plt.xlabel('Ángulo inicial θ (°)')
plt.ylabel('Alcance final x (m)')
plt.title(f'Alcance vs Ángulo (v₀ = {v0:.1f} m/s)\nMáx: θ*={theta_star:.2f}°, x={x_star:.2f} m')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()
from scipy.optimize import root_scalar

def miss(v0, theta_deg, target_x, target_y):
    """Devuelve y(target_x) - target_y, o np.nan si no alcanza target_x antes de caer"""
    def ev_x(t, s):
        return s[0] - target_x
    ev_x.terminal = True
    ev_x.direction = 1.0

    th = np.deg2rad(theta_deg)
    s0 = [0.0, 0.0, v0*np.cos(th), v0*np.sin(th)]

    sol = solve_ivp(rhs, (0, 60), s0,
                    events=[ev_x, ev_ground],
                    max_step=0.02, rtol=1e-8, atol=1e-10)

    # Si cae antes de llegar a target_x → sin solución
    if len(sol.t_events[0]) == 0:  # nunca alcanzó x=target_x
        return np.nan
    if len(sol.t_events[1]) > 0 and sol.t_events[1][0] < sol.t_events[0][0]:
        return np.nan

    y_at_x = sol.y[1, -1]
    return y_at_x - target_y

def angle_to_hit_target(v0, target_x, target_y):
    """Encuentra el ángulo θ que pega en (target_x, target_y)"""
    # Barrido inicial para encontrar cambio de signo
    grid = np.linspace(10, 80, 71)
    values = [miss(v0, th, target_x, target_y) for th in grid]

    # Buscar un par consecutivo donde cambie el signo
    for i in range(len(grid)-1):
        f1, f2 = values[i], values[i+1]
        if np.isnan(f1) or np.isnan(f2):
            continue
        if f1*f2 < 0:  # cambio de signo -> raíz en el medio
            sol = root_scalar(lambda th: miss(v0, th, target_x, target_y),
                              bracket=(grid[i], grid[i+1]),
                              method='bisect', xtol=1e-3)
            if sol.converged:
                return sol.root

    return None  # si no encuentra ninguna
import matplotlib.pyplot as plt
import numpy as np

# --- Usa tu función angle_to_hit_target de antes ---

v0 = 140.0
target_x = 30.0
target_y = 10

theta = angle_to_hit_target(v0, target_x, target_y)

if theta is None:
    print("⚠️ No se encontró ningún ángulo que llegue a ese punto.")
else:
    # Integrar con el ángulo hallado
    sol = integrar_trayectoria(v0, theta)
    x = sol.y[0]
    y = sol.y[1]

    # Graficar
    plt.figure(figsize=(8,5))
    plt.plot(x, y, label=f'Trayectoria (θ={theta:.2f}°)')
    plt.scatter([target_x], [target_y], color='red', s=80, zorder=5, label='Objetivo')
    plt.xlabel('x (m)')
    plt.ylabel('y (m)')
    plt.title(f'Disparo con v₀={v0:.1f} m/s para atinar a ({target_x},{target_y})')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

#punto 3
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import bisect

h = 0.1
a = 0.8
x0 = 10

def morse_potential(x):

    return (1 - np.exp(-a * (x - x0)))**2 - 1

def schrodinger_ode(x, y, epsilon):

    psi = y[0]
    psi_double_prime = (morse_potential(x) - epsilon) / h**2 * psi
    return [y[1], psi_double_prime]

def find_psi_at_end(epsilon):

    sqrt_term = np.sqrt(epsilon + 1)
    x1 = x0 - (1/a) * np.log(1 + sqrt_term)
    x2 = x0 - (1/a) * np.log(1 - sqrt_term)

    x_start = x1 - 2
    x_end = x2 + 1

    y0 = [0.0, 1e-10]

    sol = solve_ivp(
        schrodinger_ode,
        [x_start, x_end],
        y0,
        args=(epsilon,),
        dense_output=True,
        rtol=1e-6,
        atol=1e-6
    )

    return sol.sol(x_end)[0]


print("Iniciando búsqueda de energías permitidas...")
energies = []
wavefunctions = []
v_min = -1.0

energy_scan = np.linspace(v_min + 1e-6, -0.01, 1000)
psi_end_values = np.array([find_psi_at_end(e) for e in energy_scan])

for i in range(len(psi_end_values) - 1):
    if np.sign(psi_end_values[i]) != np.sign(psi_end_values[i+1]):
        e_low, e_high = energy_scan[i], energy_scan[i+1]
        try:
            eigen_energy = bisect(find_psi_at_end, e_low, e_high, xtol=1e-12)
            if not any(np.isclose(eigen_energy, en) for en in energies):
                 energies.append(eigen_energy)
        except ValueError:
            pass

energies = sorted(energies)

for E in energies:
    sqrt_term = np.sqrt(E + 1)
    x1 = x0 - (1/a) * np.log(1 + sqrt_term)
    x2 = x0 - (1/a) * np.log(1 - sqrt_term)
    x_span = [x1 - 2, x2 + 1]
    x_eval = np.linspace(x_span[0], x_span[1], 1000)

    sol = solve_ivp(schrodinger_ode, x_span, [0.0, 1e-10], args=(E,), dense_output=True, rtol=1e-8)
    psi = sol.sol(x_eval)[0]
    wavefunctions.append((x_eval, psi))

print(f"Se encontraron {len(energies)} estados ligados.")

print("Generando la gráfica...")
plt.style.use('seaborn-v0_8-whitegrid')
fig, ax = plt.subplots(figsize=(10, 8))
#morse potential
x_pot = np.linspace(2, 20, 500)
v_pot = morse_potential(x_pot)
ax.plot(x_pot, v_pot, 'k-', label='Potencial de Morse V(x)', linewidth=2.5)

#funciones de onda y niveles de energía
colors = plt.cm.viridis(np.linspace(0.95, 0.15, len(energies)))

colors = plt.cm.viridis(np.linspace(0.95, 0.15, len(energies)))

for i, (E, (x_psi, psi)) in enumerate(zip(energies, wavefunctions)):
#normalizar
    norm = np.sqrt(np.trapz(psi**2, x_psi))
    psi_normalized = psi / norm

    scaling_factor = 0.08
    #función de onda normalizada para cada nivel energético
    ax.plot(x_psi, E + psi_normalized * scaling_factor, color=colors[i], linewidth=1.5)

    ax.hlines(E, x_pot.min(), x_pot.max(), color=colors[i], linestyle='--', linewidth=1.0)

ax.set_title("Soluciones de la Ecuación de Schrödinger para el Potencial de Morse", fontsize=15)
ax.set_xlabel("Posición (x)", fontsize=12)
ax.set_ylabel("Energía ($\epsilon$)", fontsize=12)
ax.set_xlim(2, 18)
ax.set_ylim(-1.1, 0.1)
ax.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.show()

print("Generando archivo de resultados '3.txt'...")

def theoretical_energy(n, lam):
    return (2 * lam - n - 0.5) * (n + 0.5) * (1 / lam**2)

lam = 1 / (a * h)

with open("3.txt", "w") as f:
    header = f"{'n':<5}{'Energía encontrada (ε_n)':<30}{'Energía teórica':<25}{'Diferencia porcentual (%)'}\n"
    f.write(header)
    f.write("="*85 + "\n")

    for n, E_found in enumerate(energies):
        E_theo_shifted = morse_potential(x0) # = -1
        E_theo = theoretical_energy(n, lam) + E_theo_shifted

        if abs(E_theo) > 1e-9:
            diff_percent = abs((E_found - E_theo) / E_theo) * 100
        else:
            diff_percent = 0.0

        line = f"{n:<5}{E_found:<30.8f}{E_theo:<25.8f}{diff_percent:<.4f}\n"
        f.write(line)

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from tqdm import tqdm # Opcional: para una barra de progreso agradable

# --- 1. Definición del Sistema de Ecuaciones Diferenciales ---

def genetic_oscillator(t, S, alpha, beta):
    """
    Define el sistema de EDO para el circuito genético de 3 genes.

    Argumentos:
        t: tiempo actual
        S: vector de estado [m1, m2, m3, p1, p2, p3]
        alpha, beta: parámetros del modelo
    """
    # Desempacar el vector de estado para mayor claridad
    m1, m2, m3, p1, p2, p3 = S

    # Parámetros fijos del modelo
    n = 2.0
    alpha0 = alpha / 1000.0

    # Condición cíclica: la proteína p3 reprime al gen 1 (p0 = p3)
    p0 = p3

    # Ecuaciones para las concentraciones de ARNm (mRNA)
    dm1_dt = (alpha / (1.0 + p0**n)) + alpha0 - m1
    dm2_dt = (alpha / (1.0 + p1**n)) + alpha0 - m2
    dm3_dt = (alpha / (1.0 + p2**n)) + alpha0 - m3

    # Ecuaciones para las concentraciones de Proteínas
    dp1_dt = beta * (m1 - p1)
    dp2_dt = beta * (m2 - p2)
    dp3_dt = beta * (m3 - p3)

    # Retornar las derivadas como un array
    return np.array([dm1_dt, dm2_dt, dm3_dt, dp1_dt, dp2_dt, dp3_dt])

# --- 2. Simulación y Barrido de Parámetros ---

def run_simulation():
    """
    Ejecuta la simulación a través de la malla de parámetros alpha y beta.
    """
    # Definir los rangos de los parámetros en escala logarítmica
    # Se usan 50 puntos para cada parámetro para una buena resolución
    alpha_vals = np.logspace(0, 5, 50)  # α en [1, 10^5]
    beta_vals = np.logspace(0, 2, 50)   # β en [1, 100]

    # Crear una matriz para almacenar las amplitudes resultantes
    amplitudes = np.zeros((len(beta_vals), len(alpha_vals)))

    # Condiciones iniciales para el sistema (valores bajos para empezar)
    S0 = np.ones(6) * 0.1
    t_span = [0, 400]
    t_eval = np.linspace(t_span[0], t_span[1], 500)

    # Iterar sobre cada combinación de alpha y beta
    # tqdm es una librería para mostrar una barra de progreso
    for i, alpha in enumerate(tqdm(alpha_vals, desc="Procesando α")):
        for j, beta in enumerate(beta_vals):

            # Resolver el sistema de EDO
            sol = solve_ivp(
                genetic_oscillator,
                t_span,
                S0,
                args=(alpha, beta),
                t_eval=t_eval
            )

            # Calcular la amplitud de p3 en la fase final de la simulación
            # Usamos los datos donde t > 300 para asegurar oscilación estable
            final_phase_mask = sol.t > 300
            p3_final = sol.y[5, final_phase_mask] # p3 es el 6to elemento (índice 5)

            if p3_final.size > 0:
                amplitude = (np.max(p3_final) - np.min(p3_final)) / 2.0
            else:
                amplitude = 0.0 # No hubo oscilación o la simulación falló

            amplitudes[j, i] = amplitude

    return alpha_vals, beta_vals, amplitudes

# --- 3. Generación de la Gráfica ---

def plot_results(alpha_vals, beta_vals, amplitudes):
    """
    Genera y guarda la gráfica pcolormesh.
    """
    X, Y = np.meshgrid(alpha_vals, beta_vals)

    # Añadimos una pequeña constante para evitar log(0)
    log_amplitudes = np.log10(amplitudes + 1e-9)

    plt.style.use('default')
    fig, ax = plt.subplots(figsize=(10, 8))

    # Crear la gráfica de color
    pcm = ax.pcolormesh(X, Y, log_amplitudes, shading='gouraud', cmap='viridis')

    # Configurar las escalas logarítmicas
    ax.set_xscale('log')
    ax.set_yscale('log')

    # Etiquetas y Título
    ax.set_title('Amplitud de Oscilación del Circuito Genético', fontsize=16)
    ax.set_xlabel(r'$\alpha$', fontsize=14)
    ax.set_ylabel(r'$\beta$', fontsize=14)

    # Barra de color
    cbar = fig.colorbar(pcm, ax=ax)
    cbar.set_label('Logaritmo de la Amplitud (log10)', fontsize=12)

    plt.grid(True, which="both", ls="--", linewidth=0.5, alpha=0.5)

    # Guardar la figura en formato PDF
    plt.savefig('5.pdf', bbox_inches='tight')

    print("\nGráfica '5.pdf' generada exitosamente.")
    plt.show()

# --- 4. Ejecución Principal ---
if __name__ == "__main__":
    alpha_vals, beta_vals, amplitudes = run_simulation()
    plot_results(alpha_vals, beta_vals, amplitudes)

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.spatial import ConvexHull
from joblib import Parallel, delayed

def sistema(t, y, alpha):
    theta, r, p_theta, p_r = y
    dtheta_dt = p_theta / (1 + r)**2
    dr_dt = p_r
    dp_theta_dt = -alpha**2 * (1 + r) * np.sin(theta)
    dp_r_dt = alpha**2 * np.cos(theta) - r + p_theta**2 / (1 + r)**3
    return [dtheta_dt, dr_dt, dp_theta_dt, dp_r_dt]

# ección de poincare
def poincare_section(t, y, alpha):
    return y[0]
poincare_section.terminal = False
poincare_section.direction = 0

# --- 3. Función para simular un único valor de alpha ---
def simular_alpha(alpha, t_max, y0):
    sol = solve_ivp(
        fun=sistema, t_span=[0, t_max], y0=y0, args=(alpha,),
        method='DOP853', dense_output=True, events=poincare_section,
        rtol=1e-8, atol=1e-8
    )
    transient_events = int(len(sol.y_events[0]) * 0.1)
    if len(sol.y_events[0]) > transient_events:
        poincare_points = sol.y_events[0][transient_events:]
        r_vals = poincare_points[:, 1]
        pr_vals = poincare_points[:, 3]
        return alpha, r_vals, pr_vals
    else:
        return alpha, np.array([]), np.array([])

# --- Parámetros de la simulación ---
y0 = [np.pi / 2, 0, 0, 0]
t_max = 10000
alphas = np.linspace(1, 1.2, 20)

# --- 4. Ejecución en paralelo ---
print("Iniciando simulaciones en paralelo...")
results = Parallel(n_jobs=-1)(
    delayed(simular_alpha)(alpha, t_max, y0) for alpha in alphas
)
print("Simulaciones completadas.")

# --- 5. ANÁLISIS ALGORÍTMICO Y GENERACIÓN DE TXT ---
print("Realizando análisis algorítmico y generando reporte...")

# Umbral para decidir si el área es lo suficientemente grande para ser caótica
CHAOS_THRESHOLD = 0.01
analysis_results = []

for alpha, r_vals, pr_vals in results:
    area = 0.0
    classification = "Ordenado"

    # Se necesitan al menos 3 puntos para calcular un área con Convex Hull
    if r_vals.size > 2:
        points = np.vstack((r_vals, pr_vals)).T
        try:
            hull = ConvexHull(points)
            area = hull.area
        except Exception as e:
            # En casos muy ordenados, los puntos pueden ser colineales
            # y ConvexHull falla. El área es efectivamente 0.
            area = 0.0

    if area > CHAOS_THRESHOLD:
        classification = "Caótico"

    analysis_results.append((alpha, area, classification))

# Escribir los resultados en un archivo de texto
with open('analisis_caos.txt', 'w') as f:
    f.write("# Reporte de Análisis de Caos para el Péndulo Elástico\n")
    f.write("# Umbral de área para caos: {}\n".format(CHAOS_THRESHOLD))
    f.write("-" * 50 + "\n")
    f.write("{:<10} | {:<20} | {:<15}\n".format("Alpha", "Área del Atractor", "Clasificación"))
    f.write("-" * 50 + "\n")
    for alpha, area, classification in analysis_results:
        f.write("{:<10.4f} | {:<20.6f} | {:<15}\n".format(alpha, area, classification))

print("Reporte 'analisis_caos.txt' generado exitosamente.")

# --- 6. Generación del gráfico ---
plt.style.use('seaborn-v0_8-whitegrid')
fig, ax = plt.subplots(figsize=(10, 8))
cmap = plt.get_cmap('viridis')
colors = cmap(np.linspace(0, 1, len(alphas)))

for i, (alpha, r_vals, pr_vals) in enumerate(results):
    if r_vals.size > 0:
        ax.scatter(r_vals, pr_vals, s=1, color=colors[i], alpha=0.6)

ax.set_title('Sección de Poincaré ($P_r$ vs $r$ para $\\theta = 0$)', fontsize=16)
ax.set_xlabel('$r$', fontsize=12)
ax.set_ylabel('$P_r$', fontsize=12)
ax.grid(True)
sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=min(alphas), vmax=max(alphas)))
cbar = fig.colorbar(sm, ax=ax)
cbar.set_label('$\\alpha$', fontsize=12)
plt.savefig('4.pdf', bbox_inches='tight')
plt.show()

#Punto 7

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

class EcuacionLaneEmden:
    def __init__(self):
        plt.rcParams['figure.figsize'] = (12, 8)

    def runge_kutta_4(self, funcion, xi, y, paso, n):
        k1 = np.array(funcion(xi, y, n))
        k2 = np.array(funcion(xi + paso/2, y + paso*k1/2, n))
        k3 = np.array(funcion(xi + paso/2, y + paso*k2/2, n))
        k4 = np.array(funcion(xi + paso, y + paso*k3, n))
        return y + paso/6 * (k1 + 2*k2 + 2*k3 + k4)

    def sistema_lane_emden(self, xi, y, n):
        theta, theta_prima = y
        dtheta_dxi = theta_prima

        if abs(xi) < 1e-10:
            dtheta_prima_dxi = -1.0/3.0
        else:
            if n == 0:
                theta_n = 1.0
            elif n == int(n):
                theta_n = theta**int(n)
            else:
                if theta > 0:
                    theta_n = theta**n
                elif theta == 0:
                    theta_n = 0
                else:
                    theta_n = np.sign(theta) * (abs(theta)**n) if int(n) % 2 == 1 else (abs(theta)**n)
            dtheta_prima_dxi = -theta_n - (2.0/xi) * theta_prima
        return [dtheta_dxi, dtheta_prima_dxi]

    def resolver_lane_emden(self, n, xi_max=30, paso=0.005):
        puntos = int(xi_max / paso) + 1
        xi_valores = np.linspace(paso, xi_max, puntos)
        theta_valores = np.zeros(puntos)
        theta_primas = np.zeros(puntos)

        xi_0 = xi_valores[0]
        theta_valores[0] = 1.0 - xi_0**2/6.0 + xi_0**4/120.0
        theta_primas[0] = -xi_0/3.0 + xi_0**3/30.0

        for i in range(1, len(xi_valores)):
            xi_actual = xi_valores[i-1]
            y_actual = np.array([theta_valores[i-1], theta_primas[i-1]])
            y_nuevo = self.runge_kutta_4(self.sistema_lane_emden, xi_actual, y_actual, paso, n)
            theta_valores[i] = y_nuevo[0]
            theta_primas[i] = y_nuevo[1]

        return xi_valores, theta_valores, theta_primas

    def obtener_valores_referencia(self):
        return {
            0.0: {'xi_estrella': np.sqrt(6), 'masa': 4*np.pi/3 * (np.sqrt(6))**3, 'densidad_relativa': 1.0},
            1.0: {'xi_estrella': np.pi, 'masa': np.pi**2, 'densidad_relativa': 3.28987},
            1.5: {'xi_estrella': 3.65375, 'masa': 3.14159, 'densidad_relativa': 5.99071},
            2.0: {'xi_estrella': 4.35287, 'masa': 2.71406, 'densidad_relativa': 11.40254},
            3.0: {'xi_estrella': 6.89685, 'masa': 2.01824, 'densidad_relativa': 54.18250},
            4.0: {'xi_estrella': 14.97155, 'masa': 0.97580, 'densidad_relativa': 622.40788},
            5.0: {'xi_estrella': np.inf, 'masa': np.inf, 'densidad_relativa': np.inf}
        }

    def crear_tabla(self):
        valores = self.obtener_valores_referencia()
        resultados = []
        for n in [0.0, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0]:
            v = valores[n]
            resultados.append([
                n,
                v['xi_estrella'] if v['xi_estrella'] != np.inf else '∞',
                v['masa'] if v['masa'] != np.inf else '∞',
                v['densidad_relativa'] if v['densidad_relativa'] != np.inf else '∞'
            ])
        return pd.DataFrame(resultados, columns=['Índice n', 'Radio ξ*', 'Masa (M∝)', 'ρc/⟨ρ⟩'])

    def graficar_soluciones(self):
        indices = [0.0, 1.0, 1.5, 2.0, 3.0, 4.0, 4.5]
        colores = ['#440154', '#31688e', '#35b779', '#fde725', '#ff6347', '#ff1493', '#8b00ff']
        plt.figure(figsize=(12, 8))

        for i, n in enumerate(indices):
            if n == 0.0:
                xi = np.linspace(0, 30, 3000)
                theta = 1 - xi**2/6.0
            elif n == 5.0:
                continue
            else:
                xi, theta, _ = self.resolver_lane_emden(n, xi_max=30, paso=0.005)
            plt.plot(xi, theta, label=f'{n}', color=colores[i], linewidth=1.5)

        plt.xlabel('Radio adimensional ξ', fontsize=12)
        plt.ylabel('Densidad relativa θ', fontsize=12)
        plt.legend(title='Índice politrópico', bbox_to_anchor=(1.02, 1), loc='upper left')
        plt.grid(True, alpha=0.3)
        plt.xlim(0, 30)
        plt.ylim(-0.4, 1.0)
        plt.axhline(y=0, color='black', linestyle='--', alpha=0.5, linewidth=0.8)
        plt.axhline(y=1, color='gray', linestyle=':', alpha=0.3)
        plt.gca().set_facecolor('#f8f8f8')
        plt.tight_layout()
        plt.savefig('7.pdf', dpi=300, bbox_inches='tight')
        plt.show()

    def exportar_tabla(self, tabla):
        tabla.to_csv('7.csv', index=False)

if __name__ == "__main__":
    solucionador = EcuacionLaneEmden()
    tabla = solucionador.crear_tabla()
    print("\n--- TABLA DE PARÁMETROS FÍSICOS ---")
    print(tabla.to_string(index=False))
    solucionador.exportar_tabla(tabla)
    solucionador.graficar_soluciones()
    print("\nθ''(0) = -1/3 porque al expandir θ en serie de potencias en ξ y sustituir en la ecuación, "
          "el término (2/ξ)θ' se convierte en 2θ₂, quedando 3θ₂ = -1. Así se obtiene θ₂ = θ''(0) = -1/3.\n")