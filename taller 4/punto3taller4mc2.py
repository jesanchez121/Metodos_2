# -*- coding: utf-8 -*-
"""Punto3Taller4MC2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fmw3P9eMQzcR50n1AiCfRKWXC_Vf8fQ5
"""



# Punto_3.py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.integrate import solve_ivp, trapezoid
import os

# =============================================================================
# Parámetros de la simulación
# =============================================================================
L = 50.0          # Longitud del dominio espacial
Nx = 500          # Número de puntos espaciales
dx = L / Nx       # Espaciado espacial
x = np.linspace(0, L, Nx, endpoint=False)  # Dominio espacial (periódico)

delta = 0.022     # Parámetro de dispersión (δ)
T_final = 20.0    # Tiempo final de simulación

# Usar menos puntos temporales para mayor estabilidad
t_eval = np.linspace(0, T_final, 100)

# =============================================================================
# Condición inicial: onda cosenoidal
# =============================================================================
def condicion_inicial(x, L):
    """Condición inicial tipo coseno"""
    return 0.5 * np.cos(2 * np.pi * x / L)

phi0 = condicion_inicial(x, L)

# =============================================================================
# Definición de la ecuación KdV usando diferencias finitas
# =============================================================================
def kdv_equation(t, phi, delta, dx, Nx):
    """
    Calcula la derivada temporal de φ para la ecuación KdV:
    ∂φ/∂t + φ∂φ/∂x + δ²∂³φ/∂x³ = 0
    """
    # Primera derivada espacial (centrada, periódica)
    dphi_dx = np.zeros_like(phi)
    dphi_dx[1:-1] = (phi[2:] - phi[:-2]) / (2 * dx)
    dphi_dx[0] = (phi[1] - phi[-1]) / (2 * dx)
    dphi_dx[-1] = (phi[0] - phi[-2]) / (2 * dx)

    # Tercera derivada espacial (centrada, periódica)
    d3phi_dx3 = np.zeros_like(phi)
    d3phi_dx3[2:-2] = (phi[4:] - 2*phi[3:-1] + 2*phi[1:-3] - phi[:-4]) / (2 * dx**3)
    # Tratamiento especial para los bordes (periódico)
    d3phi_dx3[0] = (phi[3] - 2*phi[2] + 2*phi[-1] - phi[-2]) / (2 * dx**3)
    d3phi_dx3[1] = (phi[4] - 2*phi[3] + 2*phi[0] - phi[-1]) / (2 * dx**3)
    d3phi_dx3[-2] = (phi[1] - 2*phi[0] + 2*phi[-3] - phi[-4]) / (2 * dx**3)
    d3phi_dx3[-1] = (phi[2] - 2*phi[1] + 2*phi[-2] - phi[-3]) / (2 * dx**3)

    # Ecuación KdV: ∂φ/∂t = -φ∂φ/∂x - δ²∂³φ/∂x³
    dphi_dt = -phi * dphi_dx - delta**2 * d3phi_dx3

    return dphi_dt

# =============================================================================
# Función para calcular cantidades conservadas
# =============================================================================
def cantidades_conservadas(phi, dx, delta):
    """Calcula las cantidades conservadas de la ecuación KdV"""
    masa = trapezoid(phi, dx=dx)
    momento = trapezoid(phi**2, dx=dx)

    # Primera derivada para calcular la energía
    dphi_dx = np.gradient(phi, dx)
    energia = trapezoid((1/3)*phi**3 - (delta * dphi_dx)**2, dx=dx)

    return masa, momento, energia

# =============================================================================
# Resolución de la ecuación KdV
# =============================================================================

sol = solve_ivp(kdv_equation, [0, T_final], phi0, t_eval=t_eval,
                args=(delta, dx, Nx), method='RK45', rtol=1e-5)

phi_t = sol.y.T  # Solución en el tiempo: forma (Nt, Nx)
Nt_real = phi_t.shape[0]  # Número real de puntos temporales
t_real = sol.t  # Tiempos reales
print(f"Dimensión de phi_t: {phi_t.shape}")

# =============================================================================
# Cálculo de cantidades conservadas a lo largo del tiempo
# =============================================================================
masa_t = np.zeros(Nt_real)
momento_t = np.zeros(Nt_real)
energia_t = np.zeros(Nt_real)

for i in range(Nt_real):
    masa_t[i], momento_t[i], energia_t[i] = cantidades_conservadas(phi_t[i], dx, delta)

# =============================================================================
# Detección de solitones en el tiempo final
# =============================================================================
def detectar_solitones(phi, x, umbral=0.1):
    """Detecta solitones en el perfil de φ"""
    picos = []
    for i in range(1, len(phi)-1):
        if phi[i] > phi[i-1] and phi[i] > phi[i+1] and phi[i] > umbral:
            picos.append((x[i], phi[i]))
    return picos

solitones_finales = detectar_solitones(phi_t[-1], x)

# =============================================================================
# ANIMACIÓN 1: Evolución temporal de φ
# =============================================================================

fig1, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))

# Configurar subplot superior para la evolución
line, = ax1.plot(x, phi_t[0], 'b-', linewidth=2)
ax1.set_xlim(0, L)
ax1.set_ylim(-0.6, 0.6)
ax1.set_xlabel('x')
ax1.set_ylabel('φ(x,t)')
ax1.set_title('Evolución de la Ecuación KdV')
ax1.grid(True, alpha=0.3)

# Configurar subplot inferior para cantidades conservadas
line_masa, = ax2.plot(t_real[0], masa_t[0], 'b-', label='Masa', linewidth=2)
line_momento, = ax2.plot(t_real[0], momento_t[0], 'r-', label='Momento', linewidth=2)
line_energia, = ax2.plot(t_real[0], energia_t[0], 'g-', label='Energía', linewidth=2)
ax2.set_xlim(0, T_final)
ax2.set_ylim(min(np.min(masa_t), np.min(momento_t), np.min(energia_t)) * 1.1,
             max(np.max(masa_t), np.max(momento_t), np.max(energia_t)) * 1.1)
ax2.set_xlabel('Tiempo')
ax2.set_ylabel('Valor')
ax2.set_title('Cantidades Conservadas')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()

def animate1(frame):
    # Actualizar evolución
    line.set_ydata(phi_t[frame])
    ax1.set_title(f'Evolución de la Ecuación KdV (t={t_real[frame]:.2f})')

    # Actualizar cantidades conservadas
    line_masa.set_data(t_real[:frame+1], masa_t[:frame+1])
    line_momento.set_data(t_real[:frame+1], momento_t[:frame+1])
    line_energia.set_data(t_real[:frame+1], energia_t[:frame+1])

    return line, line_masa, line_momento, line_energia

# Crear animación (usar menos frames para archivo más pequeño)
frames_anim = min(Nt_real, 50)  # Usar máximo 50 frames
anim1 = FuncAnimation(fig1, animate1, frames=frames_anim, interval=100, blit=True)
anim1.save('3_animacion_evolucion.mp4', writer='ffmpeg', fps=10, dpi=150)
plt.close(fig1)

# =============================================================================
# ANIMACIÓN 2: Interacción de dos solitones
# =============================================================================


# Condición inicial con dos solitones bien separados
def dos_solitones(x, L):
    """Dos solitones separados"""
    A1, A2 = 0.8, 0.6  # Amplitudes diferentes
    c1, c2 = L/4, 3*L/4  # Posiciones iniciales
    b1, b2 = 2.0, 2.0   # Parámetros de ancho

    sol1 = A1 / np.cosh(b1 * (x - c1))**2
    sol2 = A2 / np.cosh(b2 * (x - c2))**2
    return sol1 + sol2

phi0_dos = dos_solitones(x, L)

# Resolver para dos solitones
sol_dos = solve_ivp(kdv_equation, [0, T_final], phi0_dos, t_eval=np.linspace(0, T_final, 80),
                    args=(delta, dx, Nx), method='RK45', rtol=1e-5)
phi_t_dos = sol_dos.y.T
t_dos = sol_dos.t
Nt_dos = phi_t_dos.shape[0]

# Crear animación
fig2, ax = plt.subplots(figsize=(10, 6))
line_dos, = ax.plot(x, phi_t_dos[0], 'b-', linewidth=2)
ax.set_xlim(0, L)
ax.set_ylim(-0.1, 1.0)
ax.set_xlabel('x')
ax.set_ylabel('φ(x,t)')
ax.set_title('Interacción de Dos Solitones')
ax.grid(True, alpha=0.3)

def animate2(frame):
    line_dos.set_ydata(phi_t_dos[frame])
    ax.set_title(f'Interacción de Dos Solitones (t={t_dos[frame]:.2f})')
    return line_dos,

anim2 = FuncAnimation(fig2, animate2, frames=min(Nt_dos, 40), interval=150, blit=True)
anim2.save('3_animacion_interaccion.mp4', writer='ffmpeg', fps=8, dpi=150)
plt.close(fig2)

# =============================================================================
# ANIMACIÓN 3: Diagrama espacio-temporal animado
# =============================================================================

fig3, ax = plt.subplots(figsize=(10, 6))
# Crear heatmap inicial
im = ax.imshow(phi_t[:1].T, aspect='auto', extent=[0, L, 0, T_final/10],
               origin='lower', cmap='viridis', vmin=-0.5, vmax=0.5)
ax.set_xlabel('x')
ax.set_ylabel('Tiempo')
ax.set_title('Diagrama Espacio-Temporal (Evolución)')
cbar = plt.colorbar(im, ax=ax)
cbar.set_label('φ(x,t)')

def animate3(frame):
    # Mostrar progresivamente más tiempo
    tiempo_mostrado = min(frame + 1, Nt_real)
    tiempo_max = t_real[tiempo_mostrado-1]

    Z = phi_t[:tiempo_mostrado].T
    im.set_data(Z)
    im.set_extent([0, L, 0, tiempo_max])
    ax.set_ylim(0, tiempo_max)
    ax.set_title(f'Diagrama Espacio-Temporal (t=0 a {tiempo_max:.1f})')
    return im,

anim3 = FuncAnimation(fig3, animate3, frames=min(Nt_real, 30), interval=200, blit=True)
anim3.save('3_animacion_heatmap.mp4', writer='ffmpeg', fps=5, dpi=150)
plt.close(fig3)

# =============================================================================
# Gráficas estáticas (para complementar)
# =============================================================================


# Gráfica 1: Evolución temporal de φ
plt.figure(figsize=(12, 8))

# Subplot 1: Perfiles de φ en diferentes tiempos
plt.subplot(2, 2, 1)
tiempos_plot = [0, Nt_real//4, Nt_real//2, 3*Nt_real//4, Nt_real-1]
colores = ['blue', 'green', 'orange', 'red', 'purple']
etiquetas = [f't={t_real[t]:.1f}' for t in tiempos_plot]

for i, t_idx in enumerate(tiempos_plot):
    plt.plot(x, phi_t[t_idx], color=colores[i], label=etiquetas[i], linewidth=2)

plt.xlabel('x')
plt.ylabel('φ(x,t)')
plt.title('Evolución de φ en la ecuación KdV')
plt.legend()
plt.grid(True, alpha=0.3)

# Subplot 2: Cantidades conservadas
plt.subplot(2, 2, 2)
plt.plot(t_real, masa_t, 'b-', label='Masa', linewidth=2)
plt.plot(t_real, momento_t, 'r-', label='Momento', linewidth=2)
plt.plot(t_real, energia_t, 'g-', label='Energía', linewidth=2)
plt.xlabel('Tiempo')
plt.ylabel('Valor')
plt.title('Cantidades Conservadas')
plt.legend()
plt.grid(True, alpha=0.3)

# Subplot 3: Detalle de solitones en tiempo final
plt.subplot(2, 2, 3)
plt.plot(x, phi_t[-1], 'k-', linewidth=2, label='φ(x,t final)')

if solitones_finales:
    for pos, amp in solitones_finales:
        plt.plot(pos, amp, 'ro', markersize=8, markeredgewidth=2,
                 markerfacecolor='none', label=f'Solitón A={amp:.2f}')

plt.xlabel('x')
plt.ylabel('φ(x,t final)')
plt.title(f'Solitones detectados (t={T_final})')
if solitones_finales:
    plt.legend()
plt.grid(True, alpha=0.3)

# Subplot 4: Diagrama espacio-temporal
plt.subplot(2, 2, 4)
paso_t = max(1, Nt_real // 20)
indices_t = range(0, Nt_real, paso_t)
X, T = np.meshgrid(x, t_real[indices_t])
Z = phi_t[indices_t]

contour = plt.contourf(X, T, Z, levels=30, cmap='viridis')
plt.colorbar(contour, label='φ(x,t)')
plt.xlabel('x')
plt.ylabel('Tiempo')
plt.title('Diagrama Espacio-Temporal')

plt.tight_layout()
plt.savefig('3_evolucion_solitones.pdf', dpi=300, bbox_inches='tight')
plt.savefig('3_evolucion_solitones.png', dpi=300, bbox_inches='tight')
plt.close()

# Gráfica 2: Diferentes condiciones iniciales
plt.figure(figsize=(10, 6))

condiciones = [
    ('Coseno', lambda x, L: 0.5 * np.cos(2 * np.pi * x / L)),
    ('Gaussiana', lambda x, L: 0.8 * np.exp(-0.1 * (x - L/2)**2)),
    ('Dos picos', lambda x, L: 0.6 * np.exp(-0.2 * (x - L/3)**2) + 0.4 * np.exp(-0.2 * (x - 2*L/3)**2))
]

for nombre, cond_func in condiciones:
    phi0_ci = cond_func(x, L)
    sol_ci = solve_ivp(kdv_equation, [0, T_final], phi0_ci, t_eval=[0, T_final],
                      args=(delta, dx, Nx), method='RK45', rtol=1e-5)
    phi_final = sol_ci.y.T[-1]
    plt.plot(x, phi_final, label=nombre, linewidth=2)

plt.xlabel('x')
plt.ylabel('φ(x,t final)')
plt.title('Diferentes Condiciones Iniciales')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('3_condiciones_iniciales.pdf', dpi=300, bbox_inches='tight')
plt.savefig('3_condiciones_iniciales.png', dpi=300, bbox_inches='tight')
plt.close()

# =============================================================================
# Informe de resultados
# =============================================================================
print("\n=== RESULTADOS DE LA SIMULACIÓN KdV ===")
print(f"Parámetros: L={L}, δ={delta}, T_final={T_final}")
print(f"Puntos espaciales: Nx={Nx}, Puntos temporales: {Nt_real}")
print(f"Número de solitones detectados: {len(solitones_finales)}")

if solitones_finales:
    print("Solitones detectados (posición, amplitud, velocidad≈A/3):")
    for i, (pos, amp) in enumerate(solitones_finales):
        velocidad = amp / 3
        print(f"  Solitón {i+1}: x={pos:.2f}, A={amp:.3f}, v≈{velocidad:.3f}")

error_masa = np.max(np.abs(masa_t - masa_t[0]))
error_momento = np.max(np.abs(momento_t - momento_t[0]))
error_energia = np.max(np.abs(energia_t - energia_t[0]))

print(f"\nConservación de cantidades (error absoluto máximo):")
print(f"  Masa: {error_masa:.2e}")
print(f"  Momento: {error_momento:.2e}")
print(f"  Energía: {error_energia:.2e}")

# Guardar resumen
with open('3_resumen_resultados.txt', 'w') as f:
    f.write("RESUMEN - SIMULACIÓN ECUACIÓN KdV\n")
    f.write("================================\n\n")
    f.write("ESTUDIO DE SOLITONES EN LA ECUACIÓN KORTEWEG-DE VRIES\n\n")

    f.write("PARÁMETROS DE SIMULACIÓN:\n")
    f.write(f"  Longitud del dominio: L = {L}\n")
    f.write(f"  Parámetro de dispersión: δ = {delta}\n")
    f.write(f"  Tiempo final: T_final = {T_final}\n")
    f.write(f"  Puntos espaciales: Nx = {Nx}\n")
    f.write(f"  Puntos temporales: {Nt_real}\n\n")

    f.write("RESULTADOS PRINCIPALES:\n")
    f.write(f"  Número de solitones formados: {len(solitones_finales)}\n")
    if solitones_finales:
        f.write("  Características de los solitones:\n")
        for i, (pos, amp) in enumerate(solitones_finales):
            velocidad = amp / 3
            f.write(f"    • Solitón {i+1}: posición = {pos:.2f}, amplitud = {amp:.3f}, velocidad ≈ {velocidad:.3f}\n")


    f.write("PROPIEDADES OBSERVADAS DE LOS SOLITONES:\n")
    f.write("  1. FORMACIÓN: La condición inicial cosenoidal se descompone en solitones\n")
    f.write("  2. VELOCIDAD: Los solitones más altos son más rápidos (v ∝ A)\n")
    f.write("  3. INTERACCIÓN: Conservan su forma después de colisionar\n")
    f.write("  4. ESTABILIDAD: Son soluciones estables de la ecuación KdV\n")
    f.write("  5. CONSERVACIÓN: La simulación muestra buena conservación numérica\n")