# -*- coding: utf-8 -*-
"""2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12OA37_mkP6hFABlts82c7zqq1POezU5E
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

A = 1000
B = 20
t_half_U = 23.4 / 60 / 24  # días (23.4 min)
t_half_Np = 2.36           # días
lambda_U = np.log(2) / t_half_U
lambda_Np = np.log(2) / t_half_Np

Y0 = [10, 10, 10]  # [U, Np, Pu]
t_max = 30
dt = 0.01
t_eval = np.linspace(0, t_max, int(t_max/dt))

def dYdt(t, y):
    U, Np, Pu = y
    dU = A - lambda_U * U
    dNp = lambda_U * U - lambda_Np * Np
    dPu = lambda_Np * Np - B * Pu
    return [dU, dNp, dPu]

sol = solve_ivp(dYdt, [0, t_max], Y0, t_eval=t_eval)

t = sol.t
U, Np, Pu = sol.y


plt.figure(figsize=(8, 6))
plt.plot(t, U, label="Uranio-239 (U)")
plt.plot(t, Np, label="Neptunio-239 (Np)")
plt.plot(t, Pu, label="Plutonio-239 (Pu)")
plt.xlabel("Tiempo (días)")
plt.ylabel("Cantidad")
plt.title("Evolución determinista de los isótopos (2.a)")
plt.legend()
plt.tight_layout()
plt.xscale("log")
plt.yscale("log")
plt.savefig("2.a.pdf")

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

t_eval = np.linspace(0, t_max, int(t_max/dt))
sol = solve_ivp(dYdt, [0, t_max], Y0, t_eval=t_eval)
t_det, U_det, Np_det, Pu_det = sol.t, sol.y[0], sol.y[1], sol.y[2]

# 2.b Estocástico (SDE Runge-Kutta orden 2)

def simulate_SDE(Y0, t_max, dt):
    n_steps = int(t_max / dt)
    U, Np, Pu = np.zeros(n_steps), np.zeros(n_steps), np.zeros(n_steps)
    U[0], Np[0], Pu[0] = Y0
    for i in range(1, n_steps):
        u, n, p = U[i-1], Np[i-1], Pu[i-1]

        mu_u = A - lambda_U * u
        mu_n = lambda_U * u - lambda_Np * n
        mu_p = lambda_Np * n - B * p

        sigma_u = np.sqrt(abs(A + lambda_U * u))
        sigma_n = np.sqrt(abs(lambda_U * u + lambda_Np * n))
        sigma_p = np.sqrt(abs(lambda_Np * n + B * p))

        W = np.random.normal()
        S = np.random.choice([-1, 1])
        # K1
        K1_u = dt * mu_u + (W + S) * np.sqrt(dt) * sigma_u
        K1_n = dt * mu_n + (W + S) * np.sqrt(dt) * sigma_n
        K1_p = dt * mu_p + (W + S) * np.sqrt(dt) * sigma_p
        # K2
        K2_u = dt * (A - lambda_U * (u + K1_u)) + (W + S) * np.sqrt(dt) * np.sqrt(abs(A + lambda_U * (u + K1_u)))
        K2_n = dt * (lambda_U * (u + K1_u) - lambda_Np * (n + K1_n)) + (W + S) * np.sqrt(dt) * np.sqrt(abs(lambda_U * (u + K1_u) + lambda_Np * (n + K1_n)))
        K2_p = dt * (lambda_Np * (n + K1_n) - B * (p + K1_p)) + (W + S) * np.sqrt(dt) * np.sqrt(abs(lambda_Np * (n + K1_n) + B * (p + K1_p)))

        U[i] = max(0, u + 0.5 * (K1_u + K2_u))
        Np[i] = max(0, n + 0.5 * (K1_n + K2_n))
        Pu[i] = max(0, p + 0.5 * (K1_p + K2_p))
    return np.linspace(0, t_max, n_steps), U, Np, Pu

# 2.c Gillespie exacto
def simulate_Gillespie(Y0, t_max):
    U, Np, Pu = Y0
    t, U_list, Np_list, Pu_list = [0], [U], [Np], [Pu]
    while t[-1] < t_max:
        rates = np.array([A, lambda_U*U, lambda_Np*Np, B*Pu])
        total = rates.sum()
        if total == 0:
            break
        tau = np.random.exponential(1/total)
        r = np.random.choice(4, p=rates/total)
        if r == 0: U += 1
        elif r == 1: U -= 1; Np += 1
        elif r == 2: Np -= 1; Pu += 1
        elif r == 3: Pu -= 1
        t.append(t[-1] + tau)
        U_list.append(max(0, U))
        Np_list.append(max(0, Np))
        Pu_list.append(max(0, Pu))
    return np.array(t), np.array(U_list), np.array(Np_list), np.array(Pu_list)

# Graficar en subplots

fig, axs = plt.subplots(3, 1, figsize=(8, 10), sharex=True)

# Determinista
axs[0].plot(t_det, U_det, 'k', label="Determinista")
axs[1].plot(t_det, Np_det, 'k', label="Determinista")
axs[2].plot(t_det, Pu_det, 'k', label="Determinista")

# SDE
for _ in range(n_traj):
    t_sde, U_sde, Np_sde, Pu_sde = simulate_SDE(Y0, t_max, dt)
    axs[0].plot(t_sde, U_sde, alpha=0.5)
    axs[1].plot(t_sde, Np_sde, alpha=0.5)
    axs[2].plot(t_sde, Pu_sde, alpha=0.5)
    plt.xscale("log")
    plt.yscale("log")
# Gillespie
for _ in range(n_traj):
    t_g, U_g, Np_g, Pu_g = simulate_Gillespie(Y0, t_max)
    axs[0].step(t_g, U_g, where="post", alpha=0.5)
    axs[1].step(t_g, Np_g, where="post", alpha=0.5)
    axs[2].step(t_g, Pu_g, where="post", alpha=0.5)
    plt.xscale("log")
    plt.yscale("log")
# Etiquetas
labels = ["Uranio-239", "Neptunio-239", "Plutonio-239"]
for i, ax in enumerate(axs):
    ax.set_ylabel(labels[i])
    ax.legend()
axs[2].set_xlabel("Tiempo (días)")

plt.tight_layout()
plt.savefig("2.pdf")

#2.d
import numpy as np
from scipy.integrate import solve_ivp
from scipy.stats import beta as beta_dist


A, B = 1000.0, 20.0
t_half_U = 23.4/(60*24)
t_half_Np = 2.36
lambda_U = np.log(2)/t_half_U
lambda_Np = np.log(2)/t_half_Np
y0 = np.array([10.0, 10.0, 10.0])
t_max, DT = 30.0, 0.05
N = 1000  # número de trayectorias
PU_CRIT = 80.0

def rhs(t,y):
    U,Np,Pu=y
    return [A-lambda_U*U,
            lambda_U*U-lambda_Np*Np,
            lambda_Np*Np-B*Pu]
sol = solve_ivp(rhs,(0,t_max),y0,t_eval=np.linspace(0,t_max,2000))
pu_det_max = sol.y[2].max()
det_hit = pu_det_max >= PU_CRIT

#SRK2 vectorizado
steps = int(t_max/DT)
sqrt_dt = np.sqrt(DT)

U = np.full(N,10.0)
Np = np.full(N,10.0)
Pu = np.full(N,10.0)
hit = np.zeros(N, dtype=bool)

rng = np.random.default_rng(42)

for _ in range(steps):
    mu1 = np.stack([A-lambda_U*U,
                    lambda_U*U-lambda_Np*Np,
                    lambda_Np*Np-B*Pu],axis=1)
    sigma1 = np.stack([np.sqrt(A+lambda_U*U),
                       np.sqrt(lambda_U*U+lambda_Np*Np),
                       np.sqrt(lambda_Np*Np+B*Pu)],axis=1)
    W = rng.normal(size=(N,3))
    S = rng.choice([-1,1],size=(N,3))
    K1 = DT*mu1 + (W-S)*sqrt_dt*sigma1
    Yt = np.maximum(np.stack([U,Np,Pu],axis=1)+K1,0)

    mu2 = np.stack([A-lambda_U*Yt[:,0],
                    lambda_U*Yt[:,0]-lambda_Np*Yt[:,1],
                    lambda_Np*Yt[:,1]-B*Yt[:,2]],axis=1)
    sigma2 = np.stack([np.sqrt(A+lambda_U*Yt[:,0]),
                       np.sqrt(lambda_U*Yt[:,0]+lambda_Np*Yt[:,1]),
                       np.sqrt(lambda_Np*Yt[:,1]+B*Yt[:,2])],axis=1)
    K2 = DT*mu2 + (W+S)*sqrt_dt*sigma2
    Ynew = np.maximum(np.stack([U,Np,Pu],axis=1)+0.5*(K1+K2),0)

    U,Np,Pu = Ynew[:,0],Ynew[:,1],Ynew[:,2]
    hit |= Pu>=PU_CRIT

k = hit.sum()
p = k/N
stderr = np.sqrt(p*(1-p)/N)
a,b = 1+k,1+N-k
ci = beta_dist.ppf([0.025,0.975],a,b)

with open("2.d.txt","w") as f:
    f.write(f"Determinista: Pu_max={pu_det_max:.2f} -> Prob={100*det_hit:.1f}%\n")
    f.write(f"SRK2 vectorizado: {k}/{N} -> p={100*p:.2f}% ± {100*stderr:.2f}%\n")
    f.write(f"IC Bayes 95%: [{100*ci[0]:.2f}%, {100*ci[1]:.2f}%]\n")
    f.write("\nDiscusión: La simulación estocástica estima la probabilidad de cruce.\n")
    f.write("El intervalo Bayesiano evita problemas con valores extremos de k.\n")