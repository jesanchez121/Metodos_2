# -*- coding: utf-8 -*-
"""1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lTMrfTEO1eWEcB4FSLRxmFqi3FOlVSVH
"""

import numpy as np
import matplotlib.pyplot as plt

def metropolis_step(lattice, beta, J):

    N = lattice.shape[0]
    i, j = np.random.randint(0, N, size=2)
    spin = lattice[i, j]

    neighbors_sum = (lattice[(i+1)%N, j] + lattice[(i-1)%N, j] +
                     lattice[i, (j+1)%N] + lattice[i, (j-1)%N])

    delta_E = 2 * J * spin * neighbors_sum

    # aceptar el cambio
    if delta_E <= 0 or np.random.rand() < np.exp(-delta_E * beta):
        # Si se acepta, el espín se voltea
        new_spin = -spin
        lattice[i, j] = new_spin
        # El cambio en la magnetización es -2*spin_viejo
        delta_m = -2 * spin
        return delta_E, delta_m
    else:
        # EN CASO DE NADA NO HAY CAMBIOS
        return 0.0, 0.0


def solve_exercise_1a():

    N = 50
    J = 1.0
    beta = 0.5
    epochs = 250000

#temperatura infinita
    lattice = np.random.choice([-1, 1], size=(N, N))

#energía y magnetización ideales
    energy = 0
    for i in range(N):
        for j in range(N):
            #solo sumar el vecino de abajo y la izquierda para evitar repetirlo
            energy -= J * lattice[i, j] * (lattice[(i+1)%N, j] + lattice[i, (j+1)%N])

    magnetization = np.sum(lattice)

#guardar la simulación
    energies = [energy / (2 * N**2)] # corregir la normalización
    magnetizations = [magnetization / N**2]

    for epoch in range(epochs):
        delta_E, delta_m = metropolis_step(lattice, beta, J)
        energy += delta_E
        magnetization += delta_m
        energies.append(energy / (2 * N**2))
        magnetizations.append(magnetization / N**2)

    plt.figure(figsize=(10, 6))
    plt.plot(energies, label='Energía', color='black', alpha=0.8)
    plt.plot(magnetizations, label='Magnetización', color='red', alpha=0.5)
    plt.xlabel('Épocas')
    plt.ylabel('Valor Normalizado')
    plt.title('1.a) Evolución hacia el Equilibrio del Modelo de Ising')
    plt.legend()
    plt.grid(True, linestyle=':')

    plt.savefig("1.a.pdf")
    plt.close()
#ejercicio 1.b
def solve_exercise_1b():

    print("\nIniciando Ejercicio 1.b: Cambio de fase...")
    N = 50
    J = 1.0
    beta_values = np.linspace(0.1, 0.9, 81)
    equilibration_steps = 100000  # para que el sistema se equilibre
    measurement_steps = 200000    # para medir la varianza de la energía

    # estado aleatorio
    lattice = np.random.choice([-1, 1], size=(N, N))

    specific_heats = []

    for i, beta in enumerate(beta_values):
        print(f"  Simulando para beta = {beta:.2f} ({i+1}/{len(beta_values)})...")

        # se equilibra el sistema (casi forzosamente, obligandolo con tantos pasos)
        # lo anterior se usa para repetir la iteración
        for _ in range(equilibration_steps):
            metropolis_step(lattice, beta, J)

        #energía para las varianzas
        energy_measurements = []
        # calcularla desde cero para la primera variación
        current_energy = 0
        for r in range(N):
            for c in range(N):
                current_energy -= J * lattice[r, c] * (lattice[(r+1)%N, c] + lattice[r, (c+1)%N])

        for _ in range(measurement_steps):
            delta_E, _ = metropolis_step(lattice, beta, J)
            current_energy += delta_E
            energy_measurements.append(current_energy)

        # cv
        energy_measurements = np.array(energy_measurements)
        # energía no normalizada
        energy_variance = np.var(energy_measurements)
        # formula completa
        Cv = (beta**2 / N**2) * energy_variance
        specific_heats.append(Cv)

    # Valor teórico del punto crítico de Onsager [cite: 70]
    beta_critical = np.log(1 + np.sqrt(2)) / (2 * J)

    # Graficar los resultados
    plt.figure(figsize=(10, 6))
    plt.plot(beta_values, specific_heats, 'k-', marker='.', markersize=4)
    plt.axvline(x=beta_critical, color='pink', linestyle='--', label=f'Punto Crítico (Teórico) β ≈ {beta_critical:.2f}')
    plt.xlabel('Beta Termodinámico (β)')
    plt.ylabel('Capacidad Calorífica (Cv)')
    plt.title('1.b) Cambio de Fase en el Modelo de Ising')
    plt.legend()
    plt.grid(True, linestyle=':')

    # Guardar la gráfica como pide el enunciado [cite: 74]
    plt.savefig("1.b.pdf")
    plt.close()


if __name__ == '__main__':
    solve_exercise_1a()
    solve_exercise_1b()

#bono
import numpy as np
import matplotlib.pyplot as plt
from collections import deque
from matplotlib.backends.backend_pdf import PdfPages

def get_domains(lattice):

    N = lattice.shape[0]
    visited = np.zeros_like(lattice, dtype=bool)
    domain_sizes = []

    for i in range(N):
        for j in range(N):
            if not visited[i, j]:

                domain_size = 0
                current_spin = lattice[i, j]
                q = deque([(i, j)])
                visited[i, j] = True

                while q:
                    r, c = q.popleft()
                    domain_size += 1


                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = (r + dr) % N, (c + dc) % N

                        if not visited[nr, nc] and lattice[nr, nc] == current_spin:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                domain_sizes.append(domain_size)

    return np.array(domain_sizes)

def metropolis_step(lattice, beta, J):

    N = lattice.shape[0]
    i, j = np.random.randint(0, N, size=2)
    spin = lattice[i, j]

    neighbors_sum = (lattice[(i+1)%N, j] + lattice[(i-1)%N, j] +
                     lattice[i, (j+1)%N] + lattice[i, (j-1)%N])

    delta_E = 2 * J * spin * neighbors_sum

    if delta_E < 0 or np.random.rand() < np.exp(-delta_E * beta):
        lattice[i, j] = -spin

def ising_simulation_with_domains(N=50, J=1, beta=0.5, epochs=250000, sample_interval=1000):

    lattice = np.random.choice([-1, 1], size=(N, N))

    avg_domain_sizes = []
    lattice_snapshots = {}

    lattice_snapshots[0] = lattice.copy()

    for epoch in range(epochs):
        metropolis_step(lattice, beta, J)

        if epoch % sample_interval == 0:
            domains = get_domains(lattice)
            avg_domain_sizes.append(np.mean(domains))

        if epoch == epochs // 2:
            lattice_snapshots[epochs // 2] = lattice.copy()

    lattice_snapshots[epochs] = lattice.copy()

    return avg_domain_sizes, lattice_snapshots

if __name__ == '__main__':
    # Parámetros de la simulación
    N = 50
    J = 1
    beta_critico_aprox = np.log(1 + np.sqrt(2)) / (2 * J)
    beta = beta_critico_aprox * 0.95
    epochs = 250000
    sample_interval = 1000

    avg_sizes, snapshots = ising_simulation_with_domains(N, J, beta, epochs, sample_interval)

    with PdfPages('1.a_bono.pdf') as pdf:
        fig, axes = plt.subplots(1, 3, figsize=(15, 5))

        times = sorted(snapshots.keys())
        for ax, time in zip(axes, times):
            ax.imshow(snapshots[time], cmap='binary', interpolation='nearest')
            ax.set_title(f'Red en la Época {time}')
            ax.set_xticks([])
            ax.set_yticks([])

        fig.suptitle('Evolución de los Dominios Magnéticos', fontsize=16)
        pdf.savefig(fig)
        plt.close(fig)

        # --- Página 2: Gráfica del Tamaño Promedio del Dominio ---
        fig, ax = plt.subplots(figsize=(10, 6))

        time_axis = np.arange(len(avg_sizes)) * sample_interval
        ax.plot(time_axis, avg_sizes, label='Tamaño Promedio de Dominio', color='purple')
        ax.set_xlabel('Épocas')
        ax.set_ylabel('Tamaño Promedio')
        ax.set_title('Crecimiento del Tamaño Promedio de los Dominios Magnéticos')
        ax.legend()
        ax.grid(True)

        pdf.savefig(fig)
        plt.close(fig)