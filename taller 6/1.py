# -*- coding: utf-8 -*-
"""1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lTMrfTEO1eWEcB4FSLRxmFqi3FOlVSVH
"""

import numpy as np
import matplotlib.pyplot as plt

def metropolis_step(lattice, beta, J):

    N = lattice.shape[0]
    i, j = np.random.randint(0, N, size=2)
    spin = lattice[i, j]

    neighbors_sum = (lattice[(i+1)%N, j] + lattice[(i-1)%N, j] +
                     lattice[i, (j+1)%N] + lattice[i, (j-1)%N])

    delta_E = 2 * J * spin * neighbors_sum

    # aceptar el cambio
    if delta_E <= 0 or np.random.rand() < np.exp(-delta_E * beta):
        # Si se acepta, el espín se voltea
        new_spin = -spin
        lattice[i, j] = new_spin
        # El cambio en la magnetización es -2*spin_viejo
        delta_m = -2 * spin
        return delta_E, delta_m
    else:
        # EN CASO DE NADA NO HAY CAMBIOS
        return 0.0, 0.0


def solve_exercise_1a():

    N = 50
    J = 1.0
    beta = 0.5
    epochs = 250000

#temperatura infinita
    lattice = np.random.choice([-1, 1], size=(N, N))

#energía y magnetización ideales
    energy = 0
    for i in range(N):
        for j in range(N):
            #solo sumar el vecino de abajo y la izquierda para evitar repetirlo
            energy -= J * lattice[i, j] * (lattice[(i+1)%N, j] + lattice[i, (j+1)%N])

    magnetization = np.sum(lattice)

#guardar la simulación
    energies = [energy / (2 * N**2)] # corregir la normalización
    magnetizations = [magnetization / N**2]

    for epoch in range(epochs):
        delta_E, delta_m = metropolis_step(lattice, beta, J)
        energy += delta_E
        magnetization += delta_m
        energies.append(energy / (2 * N**2))
        magnetizations.append(magnetization / N**2)

    plt.figure(figsize=(10, 6))
    plt.plot(energies, label='Energía', color='black', alpha=0.8)
    plt.plot(magnetizations, label='Magnetización', color='red', alpha=0.5)
    plt.xlabel('Épocas')
    plt.ylabel('Valor Normalizado')
    plt.title('1.a) Evolución hacia el Equilibrio del Modelo de Ising')
    plt.legend()
    plt.grid(True, linestyle=':')

    plt.savefig("1.a.pdf")
    plt.close()
#ejercicio 1.b
def solve_exercise_1b():

    print("\nIniciando Ejercicio 1.b: Cambio de fase...")
    N = 50
    J = 1.0
    beta_values = np.linspace(0.1, 0.9, 81)
    equilibration_steps = 100000  # para que el sistema se equilibre
    measurement_steps = 200000    # para medir la varianza de la energía

    # estado aleatorio
    lattice = np.random.choice([-1, 1], size=(N, N))

    specific_heats = []

    for i, beta in enumerate(beta_values):
        print(f"  Simulando para beta = {beta:.2f} ({i+1}/{len(beta_values)})...")

        # se equilibra el sistema (casi forzosamente, obligandolo con tantos pasos)
        # lo anterior se usa para repetir la iteración
        for _ in range(equilibration_steps):
            metropolis_step(lattice, beta, J)

        #energía para las varianzas
        energy_measurements = []
        # calcularla desde cero para la primera variación
        current_energy = 0
        for r in range(N):
            for c in range(N):
                current_energy -= J * lattice[r, c] * (lattice[(r+1)%N, c] + lattice[r, (c+1)%N])

        for _ in range(measurement_steps):
            delta_E, _ = metropolis_step(lattice, beta, J)
            current_energy += delta_E
            energy_measurements.append(current_energy)

        # cv
        energy_measurements = np.array(energy_measurements)
        # energía no normalizada
        energy_variance = np.var(energy_measurements)
        # formula completa
        Cv = (beta**2 / N**2) * energy_variance
        specific_heats.append(Cv)

    # Valor teórico del punto crítico de Onsager [cite: 70]
    beta_critical = np.log(1 + np.sqrt(2)) / (2 * J)

    # Graficar los resultados
    plt.figure(figsize=(10, 6))
    plt.plot(beta_values, specific_heats, 'k-', marker='.', markersize=4)
    plt.axvline(x=beta_critical, color='pink', linestyle='--', label=f'Punto Crítico (Teórico) β ≈ {beta_critical:.2f}')
    plt.xlabel('Beta Termodinámico (β)')
    plt.ylabel('Capacidad Calorífica (Cv)')
    plt.title('1.b) Cambio de Fase en el Modelo de Ising')
    plt.legend()
    plt.grid(True, linestyle=':')

    # Guardar la gráfica como pide el enunciado [cite: 74]
    plt.savefig("1.b.pdf")
    plt.close()


if __name__ == '__main__':
    solve_exercise_1a()
    solve_exercise_1b()

#bono
import numpy as np
import matplotlib.pyplot as plt
from collections import deque
from scipy.ndimage import uniform_filter1d

def find_magnetic_domains(lattice):
    N = lattice.shape[0]
    visited = np.zeros_like(lattice, dtype=bool)
    domain_sizes = []
    for i in range(N):
        for j in range(N):
            if not visited[i, j]:
                domain_size = 0
                current_spin = lattice[i, j]
                q = deque([(i, j)])
                visited[i, j] = True
                while q:
                    r, c = q.popleft()
                    domain_size += 1
                    for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                        nr, nc = (r + dr) % N, (c + dc) % N
                        if not visited[nr, nc] and lattice[nr, nc] == current_spin:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                domain_sizes.append(domain_size)
    return np.array(domain_sizes)

def wolff_step(lattice, beta, J=1.0):
    N = lattice.shape[0]
    i, j = np.random.randint(0, N, size=2)
    cluster_spin = lattice[i, j]
    cluster = set([(i, j)])
    frontier = [(i, j)]
    p_add = 1 - np.exp(-2 * beta * J)
    while frontier:
        r, c = frontier.pop()
        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
            nr, nc = (r + dr) % N, (c + dc) % N
            if (nr, nc) not in cluster and lattice[nr, nc] == cluster_spin:
                if np.random.rand() < p_add:
                    cluster.add((nr, nc))
                    frontier.append((nr, nc))
    for (r, c) in cluster:
        lattice[r, c] *= -1

def run_and_plot_bonus_B():
    N = 50
    J = 1.0
    beta = 0.5
    epochs = 20000  # Wolff converge más rápido
    measure_interval = 10

    lattice = np.random.choice([-1, 1], size=(N, N))
    avg_domain_sizes, largest_domain_fracs, steps = [], [], []

    for step in range(epochs):
        wolff_step(lattice, beta, J)
        if step % measure_interval == 0:
            domains = find_magnetic_domains(lattice)
            avg_domain_sizes.append(np.mean(domains))
            largest_domain_fracs.append(domains.max() / (N*N))
            steps.append(step)

    smoothed_largest = uniform_filter1d(largest_domain_fracs, size=10)

    plt.figure(figsize=(10, 6))
    plt.plot(steps, smoothed_largest, color='darkorange', lw=2)
    plt.xlabel('Iteraciones (clusters actualizados)')
    plt.ylabel('Fracción del mayor dominio')
    plt.title('Bono')
    plt.ylim(0, 1)
    plt.grid(True, linestyle=':')
    plt.savefig("1.bono.pdf")
    plt.close()

if _name_ == "_main_":
    run_and_plot_bonus_B()
