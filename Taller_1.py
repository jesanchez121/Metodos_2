# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IPNSS4fKZUVLjo2o7L062VU5jI62HLhe
"""

import zipfile, os

zip_path = "mammography_spectra.zip"  # nombre exacto del archivo que subiste
extract_path = "mammography_spectra"
os.makedirs(extract_path, exist_ok=True)

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Listar los archivos para confirmar
for root, dirs, files in os.walk(extract_path):
    for file in files:
        print(os.path.join(root, file))

import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import Normalize
import matplotlib.patheffects as pe
from scipy.signal import find_peaks



BASE = "mammography_spectra"

def ruta_espectro(elem: str, kv: int) -> str:
    return os.path.join(BASE, f"{elem}_unfiltered_10kV-50kV", f"{elem}_{kv}kV.dat")

def leer_espectro(path: str):
    header = []
    data = []
    f = open(path, "r", encoding="utf-8", errors="ignore")
    for line in f:
          if line.startswith("#"):
              header.append(line.strip("#").strip())
          else:
                vals = [float(x) for x in line.split()]
                if len(vals) == 2:
                    data.append(vals)
    f.close()
    data = np.array(data)
    del header[1]
    return data[:,0], data[:,1], header

# --- Entradas ---
elem = input("Inserte elemento Tungsteno (W), Rodio (Rh) y Molibdeno (Mo): ")
energ = int(input("Inserte energía (10 - 50 kV): "))
intervalo = int(input("Inserte intervalo (1-40): "))

# Curvas que mostraremos
i=10
kvs_para_elemento = []
while i<=50:
  kvs_para_elemento.append(i)
  i+=intervalo

if energ not in kvs_para_elemento:
  kvs_para_elemento.append(energ)

kvs_para_elemento.sort() # efecto del kV

elementos_para_kv  = ["W", "Rh", "Mo"]                # efecto del elemento
kv_fijo_para_elem  = energ
norm = Normalize(vmin=min(kvs_para_elemento), vmax=max(kvs_para_elemento))
cmap = cm.viridis
# --- dos paneles ---
plt.figure(figsize=(12,5))

# Panel A: mismo elemento, varios kV
ax1 = plt.subplot(1,2,1)
for kv in kvs_para_elemento:
  if kv!=energ:
    e, f, h = leer_espectro(ruta_espectro(elem, kv))
    ax1.plot(e, f, lw=1, color=cmap(norm(kv)), zorder=1)
  else:
    e, f, h = leer_espectro(ruta_espectro(elem, energ))
    ax1.plot(e, f, lw=2, color=cmap(norm(energ)),
        path_effects=[pe.Stroke(linewidth=3.5, foreground="k"), pe.Normal()],
        label=f"{energ} kV", zorder=2)


sm = cm.ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])
cbar = plt.colorbar(sm, ax=ax1)
cbar.set_label("kV")
ax1.set_xlabel("Energía (keV)")
ax1.set_ylabel(r"Fluencia (fotones keV$^{-1}$ cm$^{-2}$)")
ax1.set_title(f"{elem}: efecto del kV")
ax1.legend(title="", frameon=False)
ax1.grid(True, ls=":", alpha=0.6)


# Panel B: mismo kV, distintos elementos
ax2 = plt.subplot(1,2,2)
for el in elementos_para_kv:
  if el!=elem:
    e, f, h = leer_espectro(ruta_espectro(el, energ))
    ax2.plot(e, f, lw=1, label=el,zorder=1)
  else:
    e, f, h = leer_espectro(ruta_espectro(el, energ))
    header=h
    ax2.plot(e, f, lw=2, color=cmap(norm(energ)),
        path_effects=[pe.Stroke(linewidth=3.5, foreground="k"), pe.Normal()],
        label=el, zorder=2)
ax2.set_xlabel("Energía (keV)")
ax2.set_ylabel(r"Fluencia (fotones keV$^{-1}$ cm$^{-2}$)")
ax2.set_title(f"{energ} kV: efecto del ánodo")
ax2.legend(title="Ánodo", frameon=False)
ax2.grid(True, ls=":", alpha=0.6)

# Título general y letras de panel
plt.suptitle("Espectros de mamografía: efecto del kV y del material de ánodo", y=1.02, fontsize=13)
ax1.text(0.02, 0.98, "A", transform=ax1.transAxes, va="top", ha="left", fontsize=12, weight="bold")
ax2.text(0.02, 0.98, "B", transform=ax2.transAxes, va="top", ha="left", fontsize=12, weight="bold")

plt.tight_layout()

texto_header = "\n".join(header[:9])
plt.figtext(
    0.5, -0.05,
    texto_header,
    wrap=True, ha='center', va='top',
    fontsize=9
)
plt.savefig("1.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

BASE = "mammography_spectra"

def ruta_espectro(elem: str, kv: int) -> str:
    return os.path.join(BASE, f"{elem}_unfiltered_10kV-50kV", f"{elem}_{kv}kV.dat")

def leer_espectro(path: str):
    header = []
    data = []
    f = open(path, "r", encoding="utf-8", errors="ignore")
    for line in f:
          if line.startswith("#"):
              header.append(line.strip("#").strip())
          else:
                vals = [float(x) for x in line.split()]
                if len(vals) == 2:
                    data.append(vals)
    f.close()
    data = np.array(data)
    del header[1]
    return data[:,0], data[:,1], header



def quitar_picos(x, y,margen):
    """
    Elimina picos y ±margen puntos alrededor de cada pico.
    """
    peaks, _ = find_peaks(y, prominence=1)
    mask = np.ones(len(y), dtype=bool)
    for p in peaks:
        ini = max(0, p - margen)
        fin = min(len(y), p + margen + 1)
        mask[ini:fin] = False

    return x[mask], y[mask], peaks, mask

plt.figure(figsize=(5,4))

for i in range(0,40,10):
    e, f, h = leer_espectro(ruta_espectro("Mo", i+10))
    x_sin, y_sin, picos, mask = quitar_picos(e, f, margen=1)  # recalcular aquí
    plt.plot(e, f, 'k-', lw=1)
    if i==0:                                # espectro original
      plt.scatter(e[~mask], f[~mask], label="Eliminados", color='red', s=20)
    else:
      plt.scatter(e[~mask], f[~mask], color='red', s=20)        # puntos eliminados
plt.legend()
plt.xlabel("Energía (keV)")
plt.ylabel("Intensidad")
plt.grid(True, ls=":", alpha=0.6)
plt.tight_layout()
plt.savefig("2.a.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

from scipy.optimize import curve_fit
import numpy as np
import matplotlib.pyplot as plt
BASE = "mammography_spectra"

def ruta_espectro(elem: str, kv: int) -> str:
    return os.path.join(BASE, f"{elem}_unfiltered_10kV-50kV", f"{elem}_{kv}kV.dat")

def leer_espectro(path: str):
    header = []
    data = []
    f = open(path, "r", encoding="utf-8", errors="ignore")
    for line in f:
          if line.startswith("#"):
              header.append(line.strip("#").strip())
          else:
                vals = [float(x) for x in line.split()]
                if len(vals) == 2:
                    data.append(vals)
    f.close()
    data = np.array(data)
    del header[1]
    return data[:,0], data[:,1], header

def quitar_picos(x, y,margen):
    """
    Elimina picos y ±margen puntos alrededor de cada pico.
    """
    peaks, _ = find_peaks(y, prominence=1)
    mask = np.ones(len(y), dtype=bool)
    for p in peaks:
        ini = max(0, p - margen)
        fin = min(len(y), p + margen + 1)
        mask[ini:fin] = False

    return x[mask], y[mask], peaks, mask
# --- 2.b: aproximar "barriga" por interpolación lineal y graficar dos ejemplos ---


# --- Modelo de continuo (Bremsstrahlung + atenuación efectiva) ---
def continuo_model(E, A, m, alpha, V):
    E = np.array(E)
    g = (V - E) ** m
    atten = np.exp(-alpha /(E**3) )
    return A * g * atten

def fit_continuo(E, Y, V):
    """
    Ajusta A, m, alpha en y ≈ A*(V-E)*E^m*exp(-alpha/E^3) para E <= V.
    bounds: (lower, upper) para [A, m, alpha]
    """
    sel = (E > 0) & (E <= V) & np.isfinite(Y)
    x = E[sel]; y = Y[sel]

    # Iniciales robustos
    A0 = (np.max(y) / (V * (V/2.0)))
    m0 = 1.0
    a0 = 100.0

    def f(xx, A, m, alpha):  # curva para curve_fit (V fijo)
        return continuo_model(xx, A, m, alpha, V)

    popt, pcov = curve_fit(f, x, y, p0=[A0, m0, a0], maxfev=20000)
    return popt, pcov

# --- 2.b: quitar picos, ajustar continuo y graficar dos ejemplos ---


# Ejemplos (dos espectros como pide el enunciado) y guardar 2.b.pdf
# --- 2.b: quitar picos, ajustar continuo y graficar dos ejemplos ---
fig, axes = plt.subplots(1, 2, figsize=(10, 4), sharey=True)

for ax, (el, kv) in zip(axes, [("W", 50), ("Rh", 50)]):
    e, f, _ = leer_espectro(ruta_espectro(el, kv))
    x_sin, y_sin, picos, mask = quitar_picos(e, f, margen=2)
    (A, m, alpha), _ = fit_continuo(x_sin, y_sin, kv)
    y_fit = continuo_model(e, A, m, alpha, kv)

    ax.plot(e, f, 'k-', lw=1.0, label="Original")
    ax.scatter(e[~mask], f[~mask], s=18, c='red', label="Eliminados")
    ax.plot(e, y_fit, lw=2.0, label="Continuo (Bremsstrahlung)")
    ax.set_title(f"{el} @ {kv} kV")
    ax.set_xlabel("Energía (keV)")
    ax.grid(True, ls=":", alpha=0.6)
    ax.legend(frameon=False)

axes[0].set_ylabel(r"Fluencia (fotones keV$^{-1}$ cm$^{-2}$)")
fig.suptitle("2.b Continuo de Bremsstrahlung ajustado tras remover picos", y=1.02)
fig.tight_layout()
fig.savefig("2.b.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

# --- 2.c: Analizar el continuo ---
import os

elementos = ["W", "Rh", "Mo"]
kvs = list(range(10, 51))

resultados = {el: {"kv": [], "Ymax": [], "Emax": [], "FWHM": []} for el in elementos}

for el in elementos:
    for kv in kvs:
        e, f, _ = leer_espectro(ruta_espectro(el, kv))
        x_sin, y_sin, picos, mask = quitar_picos(e, f, margen=1)
        (A, m, alpha), _ = fit_continuo(x_sin, y_sin, kv)

        # Malla fina para encontrar máximo y FWHM
        E_fino = np.linspace(0.01, kv, 10000)
        Y_fino = continuo_model(E_fino, A, m, alpha, kv)

        idx_max = np.argmax(Y_fino)
        Emax = E_fino[idx_max]
        Ymax = Y_fino[idx_max]

        half = Ymax / 2

# izquierda: último punto antes de la mitad
        mask_izq = Y_fino[:idx_max] >= half
        E_izq = E_fino[:idx_max][mask_izq][-1]
# derecha: primer punto después de la mitad
        mask_der = Y_fino[idx_max:] >= half
        E_der = E_fino[idx_max:][mask_der][0]

        FWHM = E_der - E_izq


        resultados[el]["kv"].append(kv)
        resultados[el]["Ymax"].append(Ymax)
        resultados[el]["Emax"].append(Emax)
        resultados[el]["FWHM"].append(FWHM)

# --- Graficar ---
fig, axes = plt.subplots(2, 2, figsize=(10, 8))
ax1, ax2, ax3, ax4 = axes.flatten()

colores = {"W": "tab:blue", "Rh": "tab:orange", "Mo": "tab:green"}

for el in elementos:
    kvs_plot = resultados[el]["kv"]
    Ymaxs = resultados[el]["Ymax"]
    Emaxs = resultados[el]["Emax"]
    FWHMs = resultados[el]["FWHM"]

    ax1.plot(kvs_plot, Ymaxs, label=el, color=colores[el])
    ax2.plot(kvs_plot, Emaxs, label=el, color=colores[el])
    ax3.plot(kvs_plot, FWHMs, label=el, color=colores[el])
    ax4.plot(Emaxs, Ymaxs, label=el, color=colores[el])

ax1.set_title("Máximo del continuo vs kV")
ax1.set_xlabel("Voltaje del tubo (kV)")
ax1.set_ylabel("Máximo (Ymax)")

ax2.set_title("Energía del máximo vs kV")
ax2.set_xlabel("Voltaje del tubo (kV)")
ax2.set_ylabel("Energía (keV)")

ax3.set_title("FWHM vs kV")
ax3.set_xlabel("Voltaje del tubo (kV)")
ax3.set_ylabel("FWHM (keV)")

ax4.set_title("Máximo vs Energía del máximo")
ax4.set_xlabel("Energía (keV)")
ax4.set_ylabel("Máximo (Ymax)")

for ax in axes.flatten():
    ax.grid(True, ls=":", alpha=0.6)
    ax.legend(frameon=False)

fig.tight_layout()
fig.savefig("2.c.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import numpy as np

# Normalización y mapa de color
norm = mcolors.Normalize(vmin=10, vmax=50)  # rango kV
cmap = cm.viridis  # colormap

# ---- 1. Encontrar el pico global ----
global_max_val = -np.inf
global_max_energy = None

for i in range(10, 51):
    e, f, h = leer_espectro(ruta_espectro("W", i))
    x_sin, y_sin, picos, mask = quitar_picos(e, f, margen=1)
    (A, m, alpha), _ = fit_continuo(x_sin, y_sin, i)
    y_fit = continuo_model(e, A, m, alpha, i)
    resid = f - y_fit
    valid = np.isfinite(e) & np.isfinite(resid)
    idx_local_max = np.argmax(resid[valid])
    local_max_val = resid[valid][idx_local_max]

    if local_max_val > global_max_val:
        global_max_val = local_max_val
        global_max_energy = e[valid][idx_local_max]


# ---- 2. Graficar solo la ventana alrededor de ese pico global ----
fig, ax = plt.subplots(figsize=(8, 5))

e_min = global_max_energy - 1.0
e_max = global_max_energy + 4.0

for i in range(10, 51):
    e, f, h = leer_espectro(ruta_espectro("W", i))
    x_sin, y_sin, picos, mask = quitar_picos(e, f, margen=1)
    (A, m, alpha), _ = fit_continuo(x_sin, y_sin, i)
    y_fit = continuo_model(e, A, m, alpha, i)

    resid = f - y_fit
    win = (e >= e_min) & (e <= e_max) & np.isfinite(resid)

    if not np.any(win):
        continue

    color = cmap(norm(i))
    ax.plot(e[win], resid[win], lw=1, color=color)

# Barra de color
sm = cm.ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])
cbar = fig.colorbar(sm, ax=ax)
cbar.set_label("kV")

# Configuración del gráfico
ax.set_xlabel("Energía (keV)")
ax.set_ylabel("Residual (fluencia - continuo)")
ax.set_title(f"Residuos para Rh")
ax.grid(True, ls=":", alpha=0.6)

plt.tight_layout()
plt.savefig("3.a.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

# =========================
# 3.b – Ajuste de picos y gráficas vs kV
# =========================
import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.signal import find_peaks

# --- Configuración de rutas ---
BASE = "mammography_spectra"

def ruta_espectro(elem: str, kv: int) -> str:
    return os.path.join(BASE, f"{elem}_unfiltered_10kV-50kV", f"{elem}_{kv}kV.dat")

# --- Lector de espectros (como lo usaste) ---
def leer_espectro(path: str):
    header = []
    data = []
    f = open(path, "r", encoding="utf-8", errors="ignore")
    for line in f:
        if line.startswith("#"):
            header.append(line.strip("#").strip())
        else:
            vals = [float(x) for x in line.split()]
            if len(vals) == 2:
                data.append(vals)
    f.close()
    data = np.array(data)
    del header[1]  # tal como lo tenías
    return data[:,0], data[:,1], header

# --- Quitar picos (como lo usaste) ---
def quitar_picos(x, y, margen):
    """
    Elimina picos y ±margen puntos alrededor de cada pico.
    """
    peaks, _ = find_peaks(y, prominence=1)
    mask = np.ones(len(y), dtype=bool)
    for p in peaks:
        ini = max(0, p - margen)
        fin = min(len(y), p + margen + 1)
        mask[ini:fin] = False
    return x[mask], y[mask], peaks, mask

# --- Modelo de continuo (tu forma) ---
def continuo_model(E, A, m, alpha, V):
    E = np.array(E)
    g = (V - E) ** m
    atten = np.exp(-alpha / (E**3))
    return A * g * atten

# --- Ajuste del continuo (tu forma, V fijo) ---
def fit_continuo(E, Y, V):
    """
    Ajusta A, m, alpha en y ≈ A*(V-E)*E^m*exp(-alpha/E^3) para E <= V.
    """
    sel = (E > 0) & (E <= V) & np.isfinite(Y)
    x = E[sel]; y = Y[sel]

    # Iniciales sencillas
    A0 = (np.max(y) / (V * (V/2.0))) if V > 0 else 1.0
    m0 = 1.0
    a0 = 100.0

    def f(xx, A, m, alpha):  # curva para curve_fit (V fijo)
        return continuo_model(xx, A, m, alpha, V)

    popt, pcov = curve_fit(f, x, y, p0=[A0, m0, a0], maxfev=20000)
    return popt, pcov

# --- Elementos y rangos fijos [a,b] (keV) por elemento ---
ELEMENTOS = ["W", "Rh", "Mo"]
RANGOS = {
    "Mo": (16.0, 19.0),
    "Rh": (19.0, 21.0),
    "W":  (9.0, 10.5),
}

# --- Ajuste del mayor pico dentro del rango [a,b] para cada espectro ---
def ajustar_pico_en_residual_rango(e, f, kv, a_keV, b_keV, margen_picos=2):
    """
    Devuelve dict {'A','x0','FWHM'} del mayor pico dentro del rango [a_keV,b_keV],
    o None si no hay datos suficientes.
    """
    # 1) Ajuste de continuo usando datos sin picos
    x_sin, y_sin, _, _ = quitar_picos(e, f, margen=margen_picos)
    (A, m, alpha), _ = fit_continuo(x_sin, y_sin, kv)
    y_cont = continuo_model(e, A, m, alpha, kv)
    resid = f - y_cont

    # 2) Datos válidos y en [a,b] keV (y dominio físico 0<E<=kv)
    valid = np.isfinite(e) & np.isfinite(resid) & (e > 0) & (e <= kv)

    e2 = e[valid]; r2 = resid[valid]

    sel = (e2 >= a_keV) & (e2 <= b_keV)
    if np.count_nonzero(sel) < 3:
        return None
    x = e2[sel]; y = r2[sel]

    # 3) Modelo Gaussiano
    def gauss(xx, a, x0, sig):
        return a * np.exp(-0.5 * ((xx - x0) / sig) ** 2)

    # 4) Semillas y bounds
    a0 = float(np.nanmax(y))
    x0_0 = float(x[np.nanargmax(y)])
    dx_min=0.1
    sig0 = max((x.max() - x.min()) / 6.0, dx_min)
    p0 = [a0, x0_0, sig0]
    popt, pcov = curve_fit(gauss, x, y, p0=p0, maxfev=20000)
    a_fit, x0_fit, sig_fit = popt
    FWHM = 2.355 * sig_fit
    return {"A": a_fit, "x0": x0_fit, "FWHM": FWHM}

# --- Acumuladores de resultados ---
res_altura = {el: {"kv": [], "A": []} for el in ELEMENTOS}
res_fwhm   = {el: {"kv": [], "FWHM": []} for el in ELEMENTOS}

# --- Bucle principal: por elemento y kV ---
for el in ELEMENTOS:
    a_keV, b_keV = RANGOS[el]
    for kv in range(10, 51):  # kV = 10..50
        # Cargar espectro (si no existe, se omite)
        e, f, _ = leer_espectro(ruta_espectro(el, kv))
        fit = ajustar_pico_en_residual_rango(e, f, kv, a_keV, b_keV, margen_picos=2)
        if fit is None:
            continue  # omitir espectros sin pico usable (permitido)
        res_altura[el]["kv"].append(kv)
        res_altura[el]["A"].append(fit["A"])

        res_fwhm[el]["kv"].append(kv)
        res_fwhm[el]["FWHM"].append(fit["FWHM"])

# --- Gráficas: guardar 3.b.pdf ---
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(11, 4.5), sharex=True)

# Altura vs kV
for el in ELEMENTOS:
    kvs = np.array(res_altura[el]["kv"])
    A   = np.array(res_altura[el]["A"])
    ax1.scatter(kvs, A, s=28, label=el)

ax1.set_xlabel("kV del tubo")
ax1.set_ylabel("Altura del pico (unid. de fluencia)")
ax1.set_title("Altura del mayor pico vs kV")
ax1.grid(True, ls=":", alpha=0.6)

# FWHM vs kV
for el in ELEMENTOS:

    kvs = np.array(res_fwhm[el]["kv"])
    F   = np.array(res_fwhm[el]["FWHM"])
    ax2.scatter(kvs, F, s=28, label=el)

ax2.set_xlabel("kV del tubo")
ax2.set_ylabel("FWHM del pico (keV)")
ax2.set_title("FWHM del mayor pico vs kV")
ax2.grid(True, ls=":", alpha=0.6)

# Leyenda común arriba
handles, labels = ax1.get_legend_handles_labels()
if handles:
    fig.legend(handles, labels, loc="upper center", ncol=len(labels), frameon=False)

fig.tight_layout(rect=[0, 0, 1, 0.92])
fig.savefig("3.b.pdf", bbox_inches="tight", pad_inches=0.1)
plt.show()

