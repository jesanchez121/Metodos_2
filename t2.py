# -*- coding: utf-8 -*-
"""T2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TZa1dTnA_tyjbzxHxU-3NguYXltcnB0q
"""

import os
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from scipy import ndimage as ndi
from scipy.signal import find_peaks, butter, filtfilt
from PIL import Image
import pandas as pd
import zipfile

SEARCH_DIRS = [Path('.'), Path.cwd(), Path('/content'), Path('/mnt/data')]

def find_file(candidates, mandatory=True, description=""):
    if isinstance(candidates, (str, Path)):
        candidates = [str(candidates)]
    for base in SEARCH_DIRS:
        for name in candidates:
            p = (base / name).expanduser().resolve()
            if p.exists():
                return p
    if mandatory:
        msg = ("No se encontró el archivo requerido"
               + (f" ({description})" if description else "")
               + "\nPrueba subiendo UNO con alguno de estos nombres: "
               + str(candidates)
               + "\nBusqué en: "
               + ", ".join(str(d.resolve()) for d in SEARCH_DIRS))
        raise FileNotFoundError(msg)
    return None

plt.rcParams['figure.dpi'] = 120
plt.rcParams['savefig.bbox'] = 'tight'

def Fourier_transform(t, y, f):
    t = np.asarray(t); y = np.asarray(y); f = np.asarray(f)
    F = []
    for fi in f:
        F.append(np.sum(y * np.exp(-2j * np.pi * fi * t)))
    return np.abs(np.array(F))

def generate_data(tmax, dt, A, freq, noise, sampling_noise=0.0):
    ts = np.arange(0, tmax + dt, dt)
    if sampling_noise > 0:
        ts = ts + np.random.normal(scale=sampling_noise, size=ts.shape)
    y = np.random.normal(loc=A*np.sin(2*np.pi*ts*freq), scale=noise, size=ts.shape)
    return ts, y

A, f0, dt, tmax = 1.0, 0.2, 0.1, 20
ts, y = generate_data(tmax, dt, A, f0, 0.05)
nyquist = 1/(2*dt)
f = np.arange(0, 2.7*nyquist, 0.01)
F = Fourier_transform(ts, y, f)
plt.figure(); plt.plot(f, F); plt.axvline(f0, linestyle='--')
plt.xlabel('Frecuencia [Hz]'); plt.ylabel('|F|'); plt.title('1.a: Transformada hasta 2.7 Nyquist')
plt.savefig('1.a.pdf'); plt.close()

SNtime_vals = np.logspace(-2, 0, 12)
SNfreq_vals = []
for SNtime in SNtime_vals:
    A = 1.0; freq0 = 0.2; noise = A / max(SNtime, 1e-9)
    ts, y = generate_data(50, 0.1, A, freq0, noise)
    fgrid = np.linspace(0, 1.0, 800)
    F = Fourier_transform(ts, y, fgrid)
    peak = np.max(F)
    back = np.std(F[int(0.6*len(fgrid)):])
    SNfreq_vals.append(peak / (back if back>0 else 1e-12))
plt.figure(); plt.loglog(SNtime_vals, SNfreq_vals, 'o-')
plt.xlabel('SN_time'); plt.ylabel('SN_freq'); plt.title('1.b: Relación SN')
plt.savefig('1.b.pdf'); plt.close()

widths = []; tmax_vals = [10, 20, 40, 80]
for T in tmax_vals:
    ts, y = generate_data(T, 0.1, 1.0, 0.2, 0.02)
    fgrid = np.linspace(0, 1.0, 4000)
    F = Fourier_transform(ts, y, fgrid)
    k = np.argmax(F); half = F[k]/2
    Li = np.where(F[:k] < half)[0]; Ri = np.where(F[k:] < half)[0]
    if Li.size==0 or Ri.size==0:
        widths.append(np.nan)
    else:
        left = Li[-1]; right = k + Ri[0]
        widths.append(fgrid[right]-fgrid[left])
plt.figure(); plt.plot(tmax_vals, widths, 'o-')
plt.xlabel('t_max [s]'); plt.ylabel('Ancho a mitad [Hz]'); plt.title('1.c: Indeterminación')
plt.savefig('1.c.pdf'); plt.close()

plt.figure()
for sn in [0.0, 0.01, 0.05]:
    ts, y = generate_data(20, 0.1, 1.0, 3.0, 0.01, sampling_noise=sn)
    fgrid = np.linspace(0, 10, 2000)
    F = Fourier_transform(ts, y, fgrid)
    plt.plot(fgrid, F, label=f'sampling_noise={sn}')
plt.legend(); plt.title('1.d: Más allá de Nyquist'); plt.xlabel('f [Hz]'); plt.ylabel('|F|')
plt.savefig('1.d.pdf'); plt.close()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, butter, filtfilt
from scipy.fft import fft, fftfreq
from astropy.timeseries import LombScargle

# ===============================
# 2.a. Importar y arreglar datos
# ===============================
# Skip the first row as it contains headers and convert relevant columns to numeric
data = pd.read_csv("SN_d_tot_V2.0.csv", comment="#", header=None, skiprows=1)
# Formato esperado: Year, Month, Day, DecimalDate, Sunspots, StdDev, NObs, Definitive
data.columns = ["Year", "Month", "Day", "Date", "Spots", "Std", "NObs", "Def"]

# Convert 'Spots' and 'Date' columns to numeric, coercing errors
data["Spots"] = pd.to_numeric(data["Spots"], errors='coerce')
data["Date"] = pd.to_numeric(data["Date"], errors='coerce')


# Reemplazar -1 (datos faltantes) con NaN and then interpolate
data["Spots"] = data["Spots"].replace(-1, np.nan)
data["Spots"] = data["Spots"].interpolate()

# Drop rows with NaN in 'Date' or 'Spots' if they exist after interpolation
data.dropna(subset=["Date", "Spots"], inplace=True)


# ===============================
# 2.b. FFT para encontrar período
# ===============================
y = data["Spots"].values
N = len(y)
dt = 1.0  # 1 dato por día (sampling diario)

Y = fft(y - np.mean(y))
freqs = fftfreq(N, dt)

# Solo frecuencias positivas
mask = freqs > 0
freqs = freqs[mask]
power = np.abs(Y[mask])

# Pico dominante
idx = np.argmax(power)
f_ciclo = freqs[idx]
periodo_dias = 1 / f_ciclo

# Guardar resultado
with open("2.b.txt", "w") as f:
    f.write(f"{periodo_dias:.2f}\n")

# ===============================
# 2.b. Filtro pasa bajas
# ===============================
def lowpass_filter(signal, cutoff, fs=1.0, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    # Ensure normalized_cutoff is within [0, 1]
    normal_cutoff = max(0, min(1, normal_cutoff))
    b, a = butter(order, normal_cutoff, btype="low", analog=False)
    return filtfilt(b, a, signal)

# Filtro: cutoff ~ 1/200 días^-1
# Recalculate y as dropna might have changed its length
y = data["Spots"].values
filtered = lowpass_filter(y, cutoff=1/200)

# Graficar original vs filtrado
plt.figure(figsize=(12, 5))
plt.plot(data["Date"], y, color="gray", alpha=0.5, label="Original")
plt.plot(data["Date"], filtered, color="red", lw=2, label="Filtrado")
plt.xlabel("Año")
plt.ylabel("Número de manchas solares")
plt.legend()
plt.tight_layout()
plt.savefig("2.b.data.pdf")
plt.close()

# ===============================
# 2.b. Máximos locales
# ===============================
# Use a distance based on the calculated period or an expected period (e.g., 11 years * 365.25 days/year)
expected_period_days = 11 * 365.25
distance_samples = int(expected_period_days / 2) # Half of the expected period in samples
if distance_samples < 1:
    distance_samples = 1 # Minimum distance is 1

peaks, _ = find_peaks(filtered, distance=distance_samples, prominence=20)
plt.figure(figsize=(10, 5))
plt.plot(data["Date"], filtered, color="red", lw=2, label="Filtrado")
plt.plot(data["Date"].iloc[peaks], filtered[peaks], "o", label="Máximos")
plt.xlabel("Año")
plt.ylabel("Manchas solares (filtrado)")
plt.legend()
plt.tight_layout()
plt.savefig("2.b.maxima.pdf")
plt.close()

#Punto 3.a

import numpy as np
from PIL import Image
from numpy.fft import fft2, ifft2, fftshift, ifftshift

# Abrir imagen
img_path = "miette.jpg"
img = Image.open(img_path)
img_array = np.array(img)

# Dimensiones
rows, cols, channels = img_array.shape

# Crear máscara gaussiana en coordenadas de píxeles
x = np.linspace(-cols//2, cols//2, cols)
y = np.linspace(-rows//2, rows//2, rows)
X, Y = np.meshgrid(x, y)

sigma = 40  # <-- controla la cantidad de desenfoque (aumentar = más borroso)
gaussian = np.exp(-(X**2 + Y**2) / (2 * sigma**2))

# Procesar cada canal
blurred = np.zeros_like(img_array, dtype=np.float64)
for c in range(channels):
    channel_fft = fftshift(fft2(img_array[:, :, c]))
    channel_fft_blur = channel_fft * gaussian
    channel_ifft = np.abs(ifft2(ifftshift(channel_fft_blur)))
    blurred[:, :, c] = channel_ifft

# Normalizar a [0,255]
blurred = np.clip(blurred, 0, 255).astype(np.uint8)

# Guardar imagen
output_path = "3.a.jpg"
Image.fromarray(blurred).save(output_path)
print(f"Imagen desenfocada guardada en {output_path}")

#Punto 3.b.a

import numpy as np
import cv2
import matplotlib.pyplot as plt


# Funciones auxiliares

def mostrar_imagen(titulo, img, cmap="gray"):
    """Muestra una imagen en escala de grises."""
    plt.figure(figsize=(6,6))
    plt.imshow(img, cmap=cmap)
    plt.axis("off")
    plt.show()


def aplicar_fft(img):
    transformada = np.fft.fft2(img)             # Aplica la Transformada Rápida de Fourier (2D)
    transformada_movida = np.fft.fftshift(transformada) # Centra las frecuencias bajas en la imagen
    magnitud = np.abs(transformada_movida)      # Obtiene la magnitud de la transformada
    magnitud_log = np.log1p(magnitud)           # Escala logarítmica para visualizar espectro
    return transformada_movida, magnitud_log    # Devuelve transformada y su espectro logarítmico


def filtrar_ruido(altura, ancho, magnitud, transformada, tolerancia=0.6, radio_centro=15, radio_pico=5):
    """
    Elimina los picos brillantes del espectro de Fourier.
    - tolerancia: fracción del máximo brillo para detectar picos.
    - radio_centro: zona central a ignorar (frecuencia baja).
    - radio_pico: tamaño del parche a anular alrededor de cada pico.
    """
    centro_y, centro_x = altura// 2, ancho //2     # Coordenadas del centro de la imagen

    # Encuentra posiciones de picos brillantes en el espectro
    indices = np.argwhere(magnitud > (np.max(magnitud) * tolerancia))

    # Copia de la transformada para modificar sin alterar original
    copia = transformada.copy()

    # Elimina los picos detectados excepto los de la zona central
    for (y, x) in indices:
        if not (((centro_y - radio_centro) < y < (centro_y + radio_centro)) and
                ((centro_x - radio_centro) < x < (centro_x + radio_centro))):
            # Anula un bloque alrededor del pico
            copia[y - radio_pico:y + radio_pico, x - radio_pico:x + radio_pico] = 0

    return copia   # Devuelve la transformada con los picos eliminados


def aplicar_ifft(transformada_filtrada):
    """Aplica transformada inversa y normaliza a 8 bits."""
    inversa_movida = np.fft.ifftshift(transformada_filtrada) # Deshace el corrimiento de frecuencias
    img_recuperada = np.fft.ifft2(inversa_movida).real       # Aplica IFFT y toma la parte real
    img_norm = cv2.normalize(img_recuperada, None, 0, 255, cv2.NORM_MINMAX) # Normaliza valores a 0–255
    return img_norm.astype(np.uint8)                         # Convierte a entero de 8 bits

# Procesamiento de imagen Pato


# Cargar imagen en escala de grises
pato = cv2.imread("p_a_t_o.jpg", cv2.IMREAD_GRAYSCALE)   # Lee la imagen del pato en escala de grises

# Procesar Pato con FFT
t_pato, mag_pato = aplicar_fft(pato)                     # Calcula FFT y espectro
t_pato_filtrado = filtrar_ruido(*pato.shape, mag_pato, t_pato, tolerancia=0.75) # Filtra picos de ruido
pato_final = aplicar_ifft(t_pato_filtrado)               # Reconstruye la imagen filtrada

cv2.imwrite("3.b.a.jpg", pato_final)                     # Guarda la imagen procesada en disco
mostrar_imagen("Pato filtrado", pato_final)              # Muestra la imagen final

#Punto 3.b.b

import numpy as np
import matplotlib.pyplot as plt


# Cargar imagen del gato
img = plt.imread("g_a_t_o.png")   # Carga la imagen del gato en escala de grises (matriz 2D)
altura_g, ancho_g = img.shape     # Obtiene la altura y el ancho de la imagen


def mostrar_imagen(titulo, img, cmap="gray"):
    plt.figure(figsize=(6,6))
    plt.imshow(img, cmap=cmap)
    plt.axis("off")
    plt.show()



transformada_ima_gato = np.fft.fft2(img)             # Aplica la Transformada Rápida de Fourier (2D)
transformada_movida_gato = np.fft.fftshift(transformada_ima_gato)  # Mueve las bajas frecuencias al centro
magnitud_transformada_movida_gato = np.abs(transformada_movida_gato)  # Calcula la magnitud de la transformada
magnitud_logaritmo_gato = np.log1p(magnitud_transformada_movida_gato) # Aplica logaritmo para visualizar mejor


# Función de filtrado
def filtrar(altura, ancho, magnitud, transformada, tolerancia=0.55):
    r = 15                                        # Radio de exclusión para proteger el centro (bajas frecuencias)
    centro_y = altura // 2                        # Coordenada Y del centro de la imagen
    centro_x = ancho // 2                         # Coordenada X del centro de la imagen

    # Encuentra los índices de los puntos brillantes (posibles ruidos en frecuencias altas)
    indices_puntos_brillantes = np.argwhere(magnitud > (np.max(magnitud) * tolerancia))

    # Lista para guardar los puntos brillantes que NO están en el centro
    indices_sin_centro = []
    for (h, a) in indices_puntos_brillantes:      # Recorre todos los picos detectados
        # Si el punto NO está dentro del cuadrado central, se guarda
        if not (((centro_y - r) < h < (centro_y + r)) and ((centro_x - r) < a < (centro_x + r))):
            indices_sin_centro.append((h, a))

    copia_transformada = transformada.copy()      # Copia de la transformada original
    for (h, a) in indices_sin_centro:             # Para cada pico fuera del centro
        copia_transformada[h-5:h+5, a-5:a+5] = 0  # Elimina un bloque de 10x10 alrededor del pico (pone a cero)

    magnitud_copia = np.abs(copia_transformada)   # Calcula magnitud de la transformada modificada
    magnitud_log = np.log1p(magnitud_copia)       # Escala logarítmica para visualización

    return magnitud_log, copia_transformada       # Devuelve la magnitud log y la transformada filtrada


# Filtrado y reconstrucción
# Aplica el filtrado con tolerancia=0.56 (quita picos brillantes)
magnitud_log_g, copia_transformada_g = filtrar(altura_g, ancho_g, magnitud_logaritmo_gato, transformada_movida_gato, 0.56)

# Desplaza la transformada filtrada para preparar la IFFT
reorganizacion_imagen_gato = np.fft.ifftshift(copia_transformada_g)

# Aplica la Transformada Inversa de Fourier para reconstruir la imagen en el espacio original
gato_final = np.fft.ifft2(reorganizacion_imagen_gato).real


ruta_guardar_gato_png = '3.b.b.png'
plt.savefig(ruta_guardar_gato_png, format="png", bbox_inches='tight')
plt.clf()


mostrar_imagen("Gato filtrado", gato_final)

import numpy as np
import matplotlib.pyplot as plt
from astropy.timeseries import LombScargle


# ===============================
# 4. Importar datos
# ===============================
data = np.loadtxt("OGLE-LMC-CEP-0001.dat")
t, y, dy = data[:,0], data[:,1], data[:,2]

# ===============================
# 4. Periodo con Lomb-Scargle
# ===============================
# Definir rango de frecuencias: entre 1/100 y 10 ciclos/día
frequency, power = LombScargle(t, y, dy).autopower(minimum_frequency=1/100, maximum_frequency=10)

# Pico principal
best_freq = frequency[np.argmax(power)]
period = 1 / best_freq

# ===============================
# 4. Fase
# ===============================
phi = np.mod(best_freq * t, 1)

# ===============================
# 4. Gráfico brillo vs fase
# ===============================
plt.figure(figsize=(8,5))
# Remove the line that enables TeX-like syntax
# plt.rcParams['text.usetex'] = True
plt.errorbar(phi, y, yerr=dy, fmt=".", color="black", alpha=0.6, label="Datos")
# Use standard phi character
plt.xlabel("Fase (ϕ)")
plt.ylabel("Brillo (mag)")
plt.title(f"OGLE Cepheid - Periodo ~ {period:.3f} días")
plt.legend()
plt.tight_layout()
plt.savefig("4.pdf")
plt.close()

import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi

# ===============================
# 5. Cargar datos del grupo 9
# ===============================
projections = np.load("9.npy")   # shape: (n_proyecciones, n_pixeles)
n_proj, n_pixels = projections.shape

# Reconstrucción inicial
recon = np.zeros((n_pixels, n_pixels))

# Ángulos uniformes entre 0° y 180°
angles = np.linspace(0, 180, n_proj, endpoint=False)

# ===============================
# 5. Reconstrucción con filtro pasa-altas
# ===============================
for proj, angle in zip(projections, angles):
    # FFT de la proyección
    F = np.fft.fft(proj)
    freq = np.fft.fftfreq(len(proj))

    # Filtro de Ram-Lak (|f|)
    F = F * np.abs(freq)

    # Transformada inversa (real)
    filtered = np.fft.ifft(F).real

    # Expandir proyección a imagen 2D
    img = np.tile(filtered[:, None], n_pixels).T

    # Rotar imagen según el ángulo
    img_rot = ndi.rotate(img, angle, reshape=False, mode="reflect")

    # Sumar contribución a la reconstrucción
    recon += img_rot

# ===============================
# 5. Guardar imagen final
# ===============================
plt.imsave("5.png", recon, cmap="gray")

